# 模板PDF模块实现详细说明

## 文档说明

本文档基于`模板.pdf`的实际结构，详细说明每个部分的实现方式、所需数据、计算公式和代码实现思路。

---

## 一、第一页：产品概览与业绩统计

### 1.1 产品基本信息区域

#### 位置和布局
- **位置**：页面顶部
- **布局**：左侧显示产品名称，右侧显示净值日期

#### 需要的数据
- **产品名称**：固定值或从配置读取（如："XX私募证券投资基金"）
- **净值日期**：报告期末日期（格式：YYYY-MM-DD）
  - 数据来源：年度末日期（如：2024-12-31）
- **成立日期**：产品成立日期（格式：YYYY-MM-DD）
  - 数据来源：配置项或从历史数据获取
- **累计净值**：报告期末的累计净值
  - 计算公式：累计净值 = 期末资产 / 初始资金
- **当前规模**：报告期末的资产规模（万元）
  - 数据来源：期末总资产
- **单位净值**：报告期末的单位净值
  - 计算公式：单位净值 = 累计净值
- **收益风险特征**：文字描述（如："绝对收益风险类型属于 高收益高风险"）
  - 数据来源：根据收益率和波动率等指标判断
- **投资策略**：产品投资策略描述
  - 数据来源：配置项
- **同策略收益排名**：同策略产品的收益排名百分比
  - 数据来源：需要外部数据或配置项

#### 实现方式
```python
# 使用reportlab绘制
from reportlab.lib.units import cm
from reportlab.pdfgen import canvas

c.setFont("SimHei", 16)  # 产品名称，粗体
c.drawString(2*cm, 27*cm, "XX私募证券投资基金")

c.setFont("SimSun", 12)  # 净值日期
c.drawString(15*cm, 27*cm, f"最新净值日期：{report_date}")

# 成立日期和累计净值
c.setFont("SimSun", 10)
c.drawString(2*cm, 26.5*cm, f"成立日期：{establish_date}  累计净值：{cumulative_nav:.4f}")

# 当前规模和单位净值
c.drawString(2*cm, 26*cm, f"当前规模：{current_scale:.2f}万元  单位净值：{unit_nav:.4f}")

# 收益风险特征
c.drawString(2*cm, 25.5*cm, f"收益风险特征：{risk_characteristic}")

# 投资策略和同策略收益排名
c.drawString(2*cm, 25*cm, f"投资策略：{investment_strategy}  同策略收益排名：{strategy_rank:.2f}%")
```

#### 数据计算逻辑
```python
# 获取报告期末日期
report_date = f"{target_year}-12-31"  # 年度报告使用年末日期

# 计算累计净值
cumulative_nav = total_assets / initial_capital

# 判断收益风险特征
if annualized_return > 20 and volatility > 30:
    risk_characteristic = "绝对收益风险类型属于 高收益高风险"
elif annualized_return > 10 and volatility < 20:
    risk_characteristic = "绝对收益风险类型属于 中等收益中等风险"
else:
    risk_characteristic = "绝对收益风险类型属于 低收益低风险"
```

---

### 1.2 业绩统计区域

#### 位置和布局
- **位置**：产品基本信息下方
- **布局**：表格形式，多行多列展示各项指标

#### 需要的数据和计算

##### 1.2.1 期间产品收益率（年化收益率）
- **显示名称**：期间产品收益率
- **计算公式**：
  ```
  期间收益率 = (期末净值 - 期初净值) / 期初净值 × 100%
  年化收益率 = ((1 + 期间收益率) ^ (365 / 实际天数)) - 1 × 100%
  ```
- **数据来源**：
  - 期初净值：该年度第一个交易日的净值（或上一年度末净值）
  - 期末净值：该年度最后一个交易日的净值
  - 实际天数：报告期间的实际交易天数
- **计算逻辑**：
  ```python
  # 计算期间净值
  initial_nav = 1.0  # 初始净值（假设从1.0开始，或从交割单获取期初资产）
  final_assets = total_assets  # 期末总资产
  initial_assets = initial_capital  # 初始资金1000万
  period_return = (final_assets - initial_assets) / initial_assets * 100
  # 年化收益率
  days = (end_date - start_date).days
  annualized_return = ((1 + period_return/100) ** (365/days) - 1) * 100
  ```

##### 1.2.2 期间收益（绝对收益）
- **显示名称**：期间收益
- **计算公式**：
  ```
  期间收益 = 期末资产 - 期初资产
  年化收益 = 期间收益 × (365 / 实际天数)
  ```
- **数据来源**：
  - 期初资产：该年度初的总资产（初始资金1000万或上一年度末资产）
  - 期末资产：该年度末的总资产
- **计算逻辑**：
  ```python
  period_profit = final_assets - initial_assets  # 单位：万元
  annualized_profit = period_profit * (365 / days)  # 年化收益
  ```

##### 1.2.3 最大回撤
- **显示名称**：最大回撤
- **计算公式**：
  ```
  最大回撤 = max((峰值 - 谷值) / 峰值 × 100%)
  ```
- **数据来源**：
  - 需要每日净值数据或每日资产数据
  - 计算整个报告期间的最大回撤
- **计算逻辑**：
  ```python
  # 需要维护每日净值序列
  daily_navs = []  # 每日净值列表
  # 计算每日净值
  for date in date_range:
      nav = calculate_nav_on_date(date)  # 计算该日期的净值
      daily_navs.append((date, nav))
  
  # 计算最大回撤
  max_drawdown = 0
  peak = daily_navs[0][1]
  for date, nav in daily_navs:
      if nav > peak:
          peak = nav
      drawdown = (peak - nav) / peak * 100
      if drawdown > max_drawdown:
          max_drawdown = drawdown
  ```

##### 1.2.4 波动率
- **显示名称**：波动率（年化）
- **计算公式**：
  ```
  波动率 = std(日收益率) × sqrt(252) × 100%
  ```
- **数据来源**：
  - 需要每日收益率序列
  - 计算日收益率的标准差
- **计算逻辑**：
  ```python
  import numpy as np
  # 计算每日收益率
  daily_returns = []
  for i in range(1, len(daily_navs)):
      ret = (daily_navs[i][1] - daily_navs[i-1][1]) / daily_navs[i-1][1]
      daily_returns.append(ret)
  
  # 计算年化波动率
  volatility = np.std(daily_returns) * np.sqrt(252) * 100
  ```

##### 1.2.5 夏普比率
- **显示名称**：夏普比率
- **计算公式**：
  ```
  夏普比率 = (年化收益率 - 无风险收益率) / 年化波动率
  ```
- **数据来源**：
  - 年化收益率（已计算）
  - 年化波动率（已计算）
  - 无风险收益率：通常使用3%或国债收益率
- **计算逻辑**：
  ```python
  risk_free_rate = 0.03  # 无风险收益率，假设3%
  sharpe_ratio = (annualized_return/100 - risk_free_rate) / (volatility/100)
  ```

##### 1.2.6 卡玛比率
- **显示名称**：卡玛比率
- **计算公式**：
  ```
  卡玛比率 = 年化收益率 / 最大回撤（绝对值）
  ```
- **数据来源**：
  - 年化收益率（已计算）
  - 最大回撤（已计算）
- **计算逻辑**：
  ```python
  calmar_ratio = (annualized_return/100) / (abs(max_drawdown)/100)
  ```

##### 1.2.7 主动收益
- **显示名称**：主动收益（年化）
- **计算公式**：
  ```
  主动收益 = 产品收益率 - 基准收益率
  年化主动收益 = ((1 + 主动收益/100) ^ (365 / 实际天数)) - 1 × 100%
  ```
- **数据来源**：
  - 产品期间收益率（已计算）
  - 基准指数期间收益率（从Tushare获取）
- **计算逻辑**：
  ```python
  # 计算主动收益
  active_return = period_return - index_return
  # 年化主动收益
  annualized_active_return = ((1 + active_return/100) ** (365/days) - 1) * 100
  ```

##### 1.2.8 β值（Beta）
- **显示名称**：β值
- **计算公式**：
  ```
  β = Cov(产品收益率, 基准收益率) / Var(基准收益率)
  ```
- **数据来源**：
  - 产品每日收益率序列
  - 基准指数每日收益率序列
- **计算逻辑**：
  ```python
  import numpy as np
  # 计算产品每日收益率
  product_returns = []
  for i in range(1, len(daily_navs)):
      ret = (daily_navs[i][1] - daily_navs[i-1][1]) / daily_navs[i-1][1]
      product_returns.append(ret)
  
  # 计算基准每日收益率
  index_returns = []
  for i in range(1, len(index_data)):
      ret = (index_data.iloc[i]['close'] - index_data.iloc[i-1]['close']) / index_data.iloc[i-1]['close']
      index_returns.append(ret)
  
  # 计算β值
  beta = np.cov(product_returns, index_returns)[0][1] / np.var(index_returns)
  ```

##### 1.2.9 同期对比
- **显示名称**：同期对比（如：沪深300）
- **计算公式**：
  ```
  同期对比收益率 = 基准指数期间收益率
  ```
- **数据来源**：
  - 需要从Tushare获取基准指数（如沪深300）的期间收益率
  - 期初指数点位、期末指数点位
- **计算逻辑**：
  ```python
  # 从Tushare获取指数数据
  import tushare as ts
  pro = ts.pro_api(token)
  # 获取沪深300指数
  index_data = pro.index_daily(ts_code='000300.SH', 
                                 start_date=start_date, 
                                 end_date=end_date)
  initial_index = index_data.iloc[0]['close']
  final_index = index_data.iloc[-1]['close']
  index_return = (final_index - initial_index) / initial_index * 100
  ```

#### 实现方式
```python
# 创建业绩统计表格
from reportlab.platypus import Table, TableStyle
from reportlab.lib import colors

data = [
    ['业绩统计', '统计期间：产品运行期间', '净值日期', report_date],
    ['期间产品收益率', f'{period_return:.2f}%', f'(年化 {annualized_return:.2f}%)', ''],
    ['期间收益', f'{period_profit:.2f}万元', f'(年化 {annualized_profit:.2f}万元)', ''],
    ['最大回撤', f'{max_drawdown:.2f}%', '', ''],
    ['波动率', f'{volatility:.2f}%', '', ''],
    ['夏普比率', f'{sharpe_ratio:.2f}', '', ''],
    ['卡玛比率', f'{calmar_ratio:.2f}', '', ''],
    ['同期对比', f'沪深300: {index_return:.2f}%', '', '']
]

table = Table(data, colWidths=[4*cm, 4*cm, 4*cm, 4*cm])
table.setStyle(TableStyle([
    ('BACKGROUND', (0, 0), (-1, 0), colors.grey),
    ('TEXTCOLOR', (0, 0), (-1, 0), colors.whitesmoke),
    ('ALIGN', (0, 0), (-1, -1), 'CENTER'),
    ('FONTNAME', (0, 0), (-1, 0), 'SimHei'),
    ('FONTSIZE', (0, 0), (-1, 0), 12),
    ('BOTTOMPADDING', (0, 0), (-1, 0), 12),
    ('BACKGROUND', (0, 1), (-1, -1), colors.beige),
    ('GRID', (0, 0), (-1, -1), 1, colors.black)
]))
```

---

### 1.3 产品规模总览

#### 位置和布局
- **位置**：业绩统计下方
- **布局**：包含统计表格和走势图
  - 统计表格：期初/期末资产规模、期初/期末产品份额、期间总申购/赎回
  - 走势图：双Y轴（资产规模/份额，申购/赎回/净申购金额）

#### 需要的数据

##### 1.3.1 产品规模统计表格数据
- **期初资产规模**：报告期初的总资产（万元）
  - 数据来源：该年度第一个交易日的资产规模，或上一年度末资产
- **期末资产规模**：报告期末的总资产（万元）
  - 数据来源：该年度最后一个交易日的资产规模
- **期初产品份额**：报告期初的产品份额（万份）
  - 计算公式：期初份额 = 期初资产规模 / 期初单位净值
- **期末产品份额**：报告期末的产品份额（万份）
  - 计算公式：期末份额 = 期末资产规模 / 期末单位净值
- **期间总申购**：报告期间的总申购金额（万元）
  - 数据来源：从交割单识别申购记录，如果没有则设为0
- **期间总赎回**：报告期间的总赎回金额（万元）
  - 数据来源：从交割单识别赎回记录，如果没有则设为0

##### 1.3.2 资产规模数据
- **数据来源**：
  - 需要计算每日的资产规模
  - 资产规模 = 持仓市值 + 现金余额
- **计算逻辑**：
  ```python
  # 计算每日资产规模
  daily_assets = []
  for date in date_range:
      # 计算该日期的持仓市值
      position_value = 0
      for stock_code, quantity in positions.items():
          price = get_stock_price(stock_code, date)  # 从Tushare获取
          position_value += quantity * price
      # 计算现金余额
      cash = initial_capital + realized_profit - total_invested
      total_assets = position_value + cash
      daily_assets.append((date, total_assets))
  ```

##### 1.3.2 产品份额数据
- **数据来源**：
  - 如果产品有份额概念，需要计算每日份额
  - 份额 = 资产规模 / 单位净值
- **计算逻辑**：
  ```python
  # 计算每日份额
  daily_shares = []
  for date, assets in daily_assets:
      nav = assets / initial_capital  # 单位净值
      shares = assets / nav if nav > 0 else initial_capital
      daily_shares.append((date, shares))
  ```

##### 1.3.3 申购/赎回数据
- **数据来源**：
  - 从交割单中识别申购/赎回记录（如果有）
  - 如果没有，可以设置为0
- **计算逻辑**：
  ```python
  # 申购/赎回金额（如果没有相关数据，设为0）
  daily_purchase = 0  # 申购金额
  daily_redeem = 0    # 赎回金额
  daily_net_purchase = daily_purchase - daily_redeem  # 净申购
  ```

#### 实现方式
```python
import matplotlib.pyplot as plt
import matplotlib.dates as mdates
from matplotlib import font_manager

# 设置中文字体
plt.rcParams['font.sans-serif'] = ['SimHei']
plt.rcParams['axes.unicode_minus'] = False

# 创建图表
fig, ax1 = plt.subplots(figsize=(12, 6))

# 左Y轴：资产规模和份额
dates = [d[0] for d in daily_assets]
assets = [d[1] for d in daily_assets]
shares = [d[1] for d in daily_shares]

ax1.plot(dates, assets, 'b-', label='资产规模', linewidth=2)
ax1.plot(dates, shares, 'g--', label='份额', linewidth=2)
ax1.set_xlabel('日期')
ax1.set_ylabel('资产规模/份额（万元/万份）', color='b')
ax1.tick_params(axis='y', labelcolor='b')
ax1.grid(True, alpha=0.3)

# 右Y轴：申购/赎回
ax2 = ax1.twinx()
purchases = [daily_purchase] * len(dates)  # 示例数据
redeems = [daily_redeem] * len(dates)
net_purchases = [daily_net_purchase] * len(dates)

ax2.bar(dates, purchases, alpha=0.3, label='申购', color='green')
ax2.bar(dates, redeems, alpha=0.3, label='赎回', color='red')
ax2.set_ylabel('申购/赎回金额（万元）', color='r')
ax2.tick_params(axis='y', labelcolor='r')

# 格式化日期
ax1.xaxis.set_major_formatter(mdates.DateFormatter('%Y-%m-%d'))
plt.xticks(rotation=45)

plt.title('产品规模走势')
plt.legend(loc='upper left')
plt.tight_layout()
plt.savefig('规模走势图.png', dpi=300, bbox_inches='tight')
```

---

### 1.4 单位净值表现

#### 位置和布局
- **位置**：产品规模走势图右侧或下方
- **布局**：折线图，显示三条线：复权累计收益、沪深300、累计超额收益

#### 需要的数据

##### 1.4.1 复权累计收益数据
- **数据来源**：
  - 计算每日单位净值
  - 单位净值 = 资产规模 / 初始资金（或初始份额）
  - 复权累计收益 = (单位净值 - 1) × 100%
- **计算逻辑**：
  ```python
  # 计算每日单位净值
  daily_navs = []
  for date, assets in daily_assets:
      nav = assets / initial_capital  # 单位净值
      daily_navs.append((date, nav))
  
  # 计算复权累计收益
  cumulative_returns = [(d[0], (d[1] - 1) * 100) for d in daily_navs]
  ```

##### 1.4.2 基准指数数据
- **数据来源**：
  - 从Tushare获取基准指数（如沪深300）的每日收盘价
  - 计算基准指数的累计收益率
- **计算逻辑**：
  ```python
  # 从Tushare获取基准指数数据
  index_data = pro.index_daily(ts_code='000300.SH', 
                                 start_date=start_date, 
                                 end_date=end_date)
  # 计算基准指数的累计收益率
  initial_index_price = index_data.iloc[0]['close']
  index_cumulative = []
  for _, row in index_data.iterrows():
      ret = (row['close'] - initial_index_price) / initial_index_price
      index_cumulative.append((row['trade_date'], ret * 100))
  ```

##### 1.4.3 累计超额收益数据
- **数据来源**：
  - 累计超额收益 = 产品复权累计收益 - 基准累计收益
- **计算逻辑**：
  ```python
  # 计算累计超额收益
  excess_returns = []
  for i in range(len(cumulative_returns)):
      date = cumulative_returns[i][0]
      # 找到对应日期的基准收益
      index_ret = next((d[1] for d in index_cumulative if d[0] == date), 0)
      excess = cumulative_returns[i][1] - index_ret
      excess_returns.append((date, excess))
  ```

#### 实现方式
```python
# 创建净值走势图
fig, ax = plt.subplots(figsize=(12, 6))

# 产品复权累计收益
nav_dates = [pd.to_datetime(d[0]) for d in cumulative_returns]
nav_values = [d[1] for d in cumulative_returns]

# 基准指数
index_dates = [pd.to_datetime(d[0]) for d in index_cumulative]
index_values = [d[1] for d in index_cumulative]

# 累计超额收益
excess_dates = [pd.to_datetime(d[0]) for d in excess_returns]
excess_values = [d[1] for d in excess_returns]

ax.plot(nav_dates, nav_values, 'b-', label='复权累计收益', linewidth=2)
ax.plot(index_dates, index_values, 'r--', label='沪深300', linewidth=2)
ax.plot(excess_dates, excess_values, 'g-.', label='累计超额收益', linewidth=2)
ax.set_xlabel('日期')
ax.set_ylabel('收益率(%)')
ax.set_title('单位净值表现')
ax.legend()
ax.grid(True, alpha=0.3)

# 格式化日期
ax.xaxis.set_major_formatter(mdates.DateFormatter('%Y-%m-%d'))
plt.xticks(rotation=45)
plt.tight_layout()
plt.savefig('净值走势图.png', dpi=300, bbox_inches='tight')
```

---

### 1.5 日收益表现

#### 位置和布局
- **位置**：单位净值表现下方
- **布局**：柱状图+折线图组合，显示日收益率和累计收益率

#### 需要的数据

##### 1.5.1 日收益率数据
- **数据来源**：
  - 计算每日的收益率
  - 日收益率 = (当日净值 - 前一日净值) / 前一日净值 × 100%
- **计算逻辑**：
  ```python
  # 计算每日收益率
  daily_returns = []
  for i in range(1, len(daily_navs)):
      date = daily_navs[i][0]
      nav_today = daily_navs[i][1]
      nav_yesterday = daily_navs[i-1][1]
      daily_return = (nav_today - nav_yesterday) / nav_yesterday * 100
      daily_returns.append((date, daily_return))
  ```

##### 1.5.2 累计收益率数据
- **数据来源**：
  - 计算每日的累计收益率
  - 累计收益率 = (当日净值 - 初始净值) / 初始净值 × 100%
- **计算逻辑**：
  ```python
  # 计算累计收益率
  cumulative_returns = []
  initial_nav = daily_navs[0][1]
  for date, nav in daily_navs:
      cum_ret = (nav - initial_nav) / initial_nav * 100
      cumulative_returns.append((date, cum_ret))
  ```

##### 1.5.3 单日最大收益和单日最大亏损
- **数据来源**：
  - 从日收益率序列中找出最大值和最小值
- **计算逻辑**：
  ```python
  # 计算单日最大收益和最大亏损
  daily_ret_values = [d[1] for d in daily_returns]
  max_daily_return = max(daily_ret_values)
  min_daily_return = min(daily_ret_values)
  
  # 找到对应的日期
  max_return_date = next(d[0] for d in daily_returns if d[1] == max_daily_return)
  min_return_date = next(d[0] for d in daily_returns if d[1] == min_daily_return)
  ```

#### 实现方式
```python
# 创建日收益表现图
fig, ax1 = plt.subplots(figsize=(12, 6))

dates = [pd.to_datetime(d[0]) for d in daily_returns]
daily_ret = [d[1] for d in daily_returns]
cum_ret = [d[1] for d in cumulative_returns[1:]]  # 从第二天开始

# 柱状图：日收益率
ax1.bar(dates, daily_ret, alpha=0.6, label='日收益率', color='blue', width=1)
ax1.set_xlabel('日期')
ax1.set_ylabel('日收益率(%)', color='b')
ax1.tick_params(axis='y', labelcolor='b')
ax1.axhline(y=0, color='black', linestyle='-', linewidth=0.5)

# 折线图：累计收益率（右Y轴）
ax2 = ax1.twinx()
ax2.plot(dates, cum_ret, 'r-o', label='累计收益率', linewidth=2, markersize=3)
ax2.set_ylabel('累计收益率(%)', color='r')
ax2.tick_params(axis='y', labelcolor='r')

# 添加最大收益和最大亏损标注
ax1.axhline(y=max_daily_return, color='green', linestyle='--', alpha=0.5, label=f'单日最大收益 {max_daily_return:.2f}%')
ax1.axhline(y=min_daily_return, color='red', linestyle='--', alpha=0.5, label=f'单日最大亏损 {min_daily_return:.2f}%')

ax1.set_title('日收益表现')
ax1.legend(loc='upper left')
ax2.legend(loc='upper right')
ax1.grid(True, alpha=0.3)

plt.xticks(rotation=45)
plt.tight_layout()
plt.savefig('日收益表现图.png', dpi=300, bbox_inches='tight')
```

---

### 1.6 收益分析表格

#### 位置和布局
- **位置**：日收益表现下方
- **布局**：表格形式，显示多个时间段的组合收益率、基准收益率、超额收益率

#### 需要的数据

##### 1.6.1 多时间段收益率计算
- **时间段**：
  - 统计期间（整个报告期）
  - 近一个月
  - 近三个月
  - 近六个月
  - 近一年
  - 今年以来
  - 成立以来
- **需要计算的指标**：
  - 组合收益率（产品收益率）
  - 基准收益率（如沪深300）
  - 超额收益率（组合收益率 - 基准收益率）

#### 计算逻辑
```python
# 计算各时间段的收益率
def calculate_period_return(nav_data, start_date, end_date):
    """
    计算指定时间段的收益率
    """
    start_nav = get_nav_on_date(nav_data, start_date)
    end_nav = get_nav_on_date(nav_data, end_date)
    return (end_nav - start_nav) / start_nav * 100

# 计算各时间段数据
periods = {
    '统计期间': (report_start_date, report_end_date),
    '近一个月': (one_month_ago, report_end_date),
    '近三个月': (three_months_ago, report_end_date),
    '近六个月': (six_months_ago, report_end_date),
    '近一年': (one_year_ago, report_end_date),
    '今年以来': (year_start_date, report_end_date),
    '成立以来': (establish_date, report_end_date)
}

# 计算各时间段的收益率
return_data = []
for period_name, (start, end) in periods.items():
    product_ret = calculate_period_return(daily_navs, start, end)
    index_ret = calculate_period_return(index_data, start, end)
    excess_ret = product_ret - index_ret
    return_data.append({
        'period': period_name,
        'product_return': product_ret,
        'index_return': index_ret,
        'excess_return': excess_ret
    })
```

#### 实现方式
```python
# 创建收益分析表格
from reportlab.platypus import Table, TableStyle

table_data = [
    ['', '*组合收益率(%)', '*基准收益率(%)', '*超额收益率(%)']
]

for data in return_data:
    table_data.append([
        data['period'],
        f"{data['product_return']:.2f}",
        f"{data['index_return']:.2f}",
        f"{data['excess_return']:.2f}"
    ])

table = Table(table_data, colWidths=[3*cm, 3*cm, 3*cm, 3*cm])
table.setStyle(TableStyle([
    ('BACKGROUND', (0, 0), (-1, 0), colors.grey),
    ('TEXTCOLOR', (0, 0), (-1, 0), colors.whitesmoke),
    ('ALIGN', (0, 0), (-1, -1), 'CENTER'),
    ('FONTNAME', (0, 0), (-1, 0), 'SimHei'),
    ('FONTSIZE', (0, 0), (-1, 0), 10),
    ('GRID', (0, 0), (-1, -1), 1, colors.black),
    ('BACKGROUND', (0, 1), (-1, -1), colors.beige)
]))
```

---

### 1.7 指标分析表格

#### 位置和布局
- **位置**：收益分析表格下方
- **布局**：详细表格，显示多个指标在多个时间段的值

#### 需要的数据和计算

##### 1.7.1 需要计算的指标
1. **收益率（年化）**：已计算
2. **波动率（年化）**：已计算
3. **跟踪误差（年化）**：
   ```
   跟踪误差 = std(产品收益率 - 基准收益率) × sqrt(252) × 100%
   ```
4. **下行波动率（年化）**：
   ```
   下行波动率 = std(负收益率) × sqrt(252) × 100%
   ```
5. **夏普比率（年化）**：已计算
6. **索提诺比率（年化）**：
   ```
   索提诺比率 = (年化收益率 - 无风险收益率) / 下行波动率
   ```
7. **信息比率（年化）**：
   ```
   信息比率 = 年化超额收益率 / 跟踪误差
   ```
8. **最大回撤**：已计算
9. **卡玛比率**：
   ```
   卡玛比率 = 年化收益率 / 最大回撤（绝对值）
   ```
10. **周胜率**：
    ```
    周胜率 = 盈利周数 / 总周数 × 100%
    ```
11. **月胜率**：
    ```
    月胜率 = 盈利月数 / 总月数 × 100%
    ```

##### 1.7.2 多时间段计算
- 每个指标都需要计算多个时间段的值（与收益分析表格相同的时间段）

#### 计算逻辑
```python
# 计算跟踪误差
def calculate_tracking_error(product_returns, index_returns):
    """
    计算跟踪误差
    """
    import numpy as np
    excess_returns = [p - i for p, i in zip(product_returns, index_returns)]
    return np.std(excess_returns) * np.sqrt(252) * 100

# 计算下行波动率
def calculate_downside_volatility(returns):
    """
    计算下行波动率
    """
    import numpy as np
    negative_returns = [r for r in returns if r < 0]
    if len(negative_returns) == 0:
        return 0
    return np.std(negative_returns) * np.sqrt(252) * 100

# 计算索提诺比率
def calculate_sortino_ratio(annualized_return, downside_volatility, risk_free_rate=0.03):
    """
    计算索提诺比率
    """
    if downside_volatility == 0:
        return 0
    return (annualized_return/100 - risk_free_rate) / (downside_volatility/100)

# 计算信息比率
def calculate_information_ratio(annualized_excess_return, tracking_error):
    """
    计算信息比率
    """
    if tracking_error == 0:
        return 0
    return (annualized_excess_return/100) / (tracking_error/100)
```

#### 实现方式
```python
# 创建指标分析表格
table_data = [
    ['指标', '统计期间', '近一个月', '近三个月', '近六个月', '近一年', '今年以来', '成立以来']
]

# 添加各项指标
indicators = [
    ('*收益率(年化)', 'annualized_return'),
    ('*波动率(年化)', 'volatility'),
    ('*跟踪误差(年化)', 'tracking_error'),
    ('*下行波动率(年化)', 'downside_volatility'),
    ('*夏普比率(年化)', 'sharpe_ratio'),
    ('*索提诺比率(年化)', 'sortino_ratio'),
    ('*信息比率(年化)', 'information_ratio'),
    ('*最大回撤', 'max_drawdown')
]

for indicator_name, indicator_key in indicators:
    row = [indicator_name]
    for period_name, _ in periods.items():
        value = get_indicator_value(indicator_key, period_name)
        row.append(f"{value:.2f}%")
    table_data.append(row)

# 添加最大回撤期间信息
table_data.append(['最大回撤期间', max_dd_start, max_dd_end, '', '', '', '', ''])

table = Table(table_data, colWidths=[2.5*cm, 2*cm, 2*cm, 2*cm, 2*cm, 2*cm, 2*cm, 2*cm])
table.setStyle(TableStyle([
    ('BACKGROUND', (0, 0), (-1, 0), colors.grey),
    ('TEXTCOLOR', (0, 0), (-1, 0), colors.whitesmoke),
    ('ALIGN', (0, 0), (-1, -1), 'CENTER'),
    ('FONTNAME', (0, 0), (-1, 0), 'SimHei'),
    ('FONTSIZE', (0, 0), (-1, 0), 9),
    ('GRID', (0, 0), (-1, -1), 1, colors.black),
    ('BACKGROUND', (0, 1), (-1, -1), colors.beige),
    ('FONTSIZE', (0, 1), (-1, -1), 8)
]))
```

---

### 1.8 收益率分析图（月度）

#### 位置和布局
- **位置**：指标分析表格下方（如果有空间）
- **布局**：柱状图+折线图组合，显示月度收益率和累计收益率

#### 需要的数据

##### 1.5.1 月度收益率
- **数据来源**：
  - 计算每个月的收益率
  - 月度收益率 = (月末净值 - 月初净值) / 月初净值 × 100%
- **计算逻辑**：
  ```python
  # 计算月度收益率
  monthly_returns = []
  for month in range(1, 13):
      month_start = f"{target_year}-{month:02d}-01"
      month_end = f"{target_year}-{month:02d}-{calendar.monthrange(target_year, month)[1]}"
      
      # 获取月初和月末净值
      nav_start = get_nav_on_date(month_start)
      nav_end = get_nav_on_date(month_end)
      
      monthly_return = (nav_end - nav_start) / nav_start * 100
      monthly_returns.append((month, monthly_return))
  ```

##### 1.5.2 累计收益率
- **数据来源**：
  - 计算每个月的累计收益率
  - 累计收益率 = (月末净值 - 初始净值) / 初始净值 × 100%
- **计算逻辑**：
  ```python
  # 计算累计收益率
  cumulative_returns = []
  initial_nav = 1.0  # 假设初始净值为1.0
  for month, _ in monthly_returns:
      month_end = f"{target_year}-{month:02d}-{calendar.monthrange(target_year, month)[1]}"
      nav_end = get_nav_on_date(month_end)
      cumulative_return = (nav_end - initial_nav) / initial_nav * 100
      cumulative_returns.append((month, cumulative_return))
  ```

#### 实现方式
```python
# 创建收益率分析图
fig, ax1 = plt.subplots(figsize=(12, 6))

months = [m[0] for m in monthly_returns]
monthly_ret = [m[1] for m in monthly_returns]
cumulative_ret = [c[1] for c in cumulative_returns]

# 柱状图：月度收益率
ax1.bar(months, monthly_ret, alpha=0.6, label='月度收益率', color='blue')
ax1.set_xlabel('月份')
ax1.set_ylabel('月度收益率(%)', color='b')
ax1.tick_params(axis='y', labelcolor='b')

# 折线图：累计收益率（右Y轴）
ax2 = ax1.twinx()
ax2.plot(months, cumulative_ret, 'r-o', label='累计收益率', linewidth=2, markersize=8)
ax2.set_ylabel('累计收益率(%)', color='r')
ax2.tick_params(axis='y', labelcolor='r')

ax1.set_title('收益率分析')
ax1.legend(loc='upper left')
ax2.legend(loc='upper right')
ax1.grid(True, alpha=0.3)
plt.tight_layout()
plt.savefig('收益率分析图.png', dpi=300, bbox_inches='tight')
```

---

## 二、第二页：风险分析与资产分布

### 2.1 动态回撤图

#### 位置和布局
- **位置**：页面顶部
- **布局**：折线图，对比产品回撤与基准回撤，并显示最大回撤相关信息

#### 需要的数据

##### 2.1.1 产品回撤数据
- **数据来源**：
  - 计算每日的回撤值
  - 回撤 = (峰值 - 当前值) / 峰值 × 100%
- **计算逻辑**：
  ```python
  # 计算每日回撤
  daily_drawdowns = []
  peak = initial_nav
  for date, nav in daily_navs:
      if nav > peak:
          peak = nav
      drawdown = (peak - nav) / peak * 100
      daily_drawdowns.append((date, drawdown))
  ```

##### 2.1.2 基准回撤数据
- **数据来源**：
  - 从Tushare获取基准指数的每日价格
  - 计算基准指数的回撤
- **计算逻辑**：
  ```python
  # 计算基准回撤
  index_drawdowns = []
  index_peak = initial_index_price
  for _, row in index_data.iterrows():
      price = row['close']
      if price > index_peak:
          index_peak = price
      drawdown = (index_peak - price) / index_peak * 100
      index_drawdowns.append((row['trade_date'], drawdown))
  ```

##### 2.1.3 最大回撤相关信息
- **产品最大回撤区间**：最大回撤的起始日期和结束日期
  - 数据来源：计算最大回撤时记录对应的日期
- **基准最大回撤区间**：基准指数的最大回撤区间
  - 数据来源：计算基准回撤时记录对应的日期
- **最大回撤修复期**：从最大回撤结束到净值恢复到峰值的时间
  - 计算公式：如果净值已恢复，修复期 = 恢复日期 - 回撤结束日期；如果未恢复，显示"-"
  - 数据来源：需要跟踪净值恢复情况

#### 计算逻辑（最大回撤修复期）
```python
# 计算最大回撤修复期
def calculate_drawdown_recovery_period(daily_navs, max_dd_start, max_dd_end):
    """
    计算最大回撤修复期
    """
    # 找到回撤结束时的净值
    dd_end_nav = next(nav for date, nav in daily_navs if date == max_dd_end)
    
    # 找到回撤开始前的峰值
    peak_before_dd = max([nav for date, nav in daily_navs if date < max_dd_start])
    
    # 查找净值恢复到峰值的日期
    recovery_date = None
    for date, nav in daily_navs:
        if date > max_dd_end and nav >= peak_before_dd:
            recovery_date = date
            break
    
    if recovery_date:
        recovery_period = (recovery_date - max_dd_end).days
        return recovery_period, recovery_date
    else:
        return None, None  # 未恢复
```

#### 实现方式
```python
# 创建动态回撤图
fig, ax = plt.subplots(figsize=(12, 6))

# 产品回撤
dd_dates = [pd.to_datetime(d[0]) for d in daily_drawdowns]
dd_values = [d[1] for d in daily_drawdowns]

# 基准回撤
index_dd_dates = [pd.to_datetime(d[0]) for d in index_drawdowns]
index_dd_values = [d[1] for d in index_drawdowns]

ax.plot(dd_dates, dd_values, 'b-', label='产品回撤', linewidth=2)
ax.plot(index_dd_dates, index_dd_values, 'r--', label='基准回撤', linewidth=2)
ax.fill_between(dd_dates, dd_values, 0, alpha=0.3, color='blue')
ax.set_xlabel('日期')
ax.set_ylabel('回撤(%)')
ax.set_title('动态回撤')
ax.legend()
ax.grid(True, alpha=0.3)
ax.invert_yaxis()  # Y轴反转，回撤向下显示

plt.xticks(rotation=45)
plt.tight_layout()
plt.savefig('动态回撤图.png', dpi=300, bbox_inches='tight')
```

---

### 2.2 大类持仓时序图

#### 位置和布局
- **位置**：动态回撤图下方
- **布局**：堆叠面积图，显示股票、基金、逆回购、现金、其他资产的占比变化

#### 需要的数据

##### 2.2.1 资产分类数据
- **数据来源**：
  - 计算每日的资产分类
  - **股票市值**：所有持仓股票的市值总和
  - **基金市值**：如果有基金持仓（公募基金等，通常为0）
  - **逆回购**：逆回购金额（通常为0）
  - **现金**：账户现金余额
  - **其他资产**：其他类型的资产
- **计算逻辑**：
  ```python
  # 计算每日资产分布
  daily_asset_distribution = []
  for date in date_range:
      # 计算股票市值
      stock_value = 0
      for stock_code, quantity in positions.items():
          price = get_stock_price(stock_code, date)
          stock_value += quantity * price
      
      # 计算基金市值（如果有基金持仓）
      fund_value = 0  # 通常为0，如果有基金持仓需要单独计算
      
      # 计算逆回购（如果有逆回购）
      repo_value = 0  # 通常为0
      
      # 计算现金
      cash = calculate_cash_balance(date)
      
      # 其他资产（如果有）
      other_value = 0
      
      total = stock_value + fund_value + repo_value + cash + other_value
      
      daily_asset_distribution.append({
          'date': date,
          'stock_pct': stock_value / total * 100 if total > 0 else 0,
          'fund_pct': fund_value / total * 100 if total > 0 else 0,
          'repo_pct': repo_value / total * 100 if total > 0 else 0,
          'cash_pct': cash / total * 100 if total > 0 else 0,
          'other_pct': other_value / total * 100 if total > 0 else 0
      })
  ```

#### 实现方式
```python
# 创建资产分布时间图
fig, ax = plt.subplots(figsize=(12, 6))

dates = [pd.to_datetime(d['date']) for d in daily_asset_distribution]
stock_pct = [d['stock_pct'] for d in daily_asset_distribution]
bond_pct = [d['bond_pct'] for d in daily_asset_distribution]
cash_pct = [d['cash_pct'] for d in daily_asset_distribution]
other_pct = [d['other_pct'] for d in daily_asset_distribution]

# 堆叠面积图
ax.fill_between(dates, 0, stock_pct, label='股票', alpha=0.7, color='blue')
ax.fill_between(dates, stock_pct, [s+b for s,b in zip(stock_pct, bond_pct)], 
                label='债券', alpha=0.7, color='green')
ax.fill_between(dates, [s+b for s,b in zip(stock_pct, bond_pct)], 
                [s+b+c for s,b,c in zip(stock_pct, bond_pct, cash_pct)], 
                label='现金', alpha=0.7, color='orange')
ax.fill_between(dates, [s+b+c for s,b,c in zip(stock_pct, bond_pct, cash_pct)], 
                [s+b+c+o for s,b,c,o in zip(stock_pct, bond_pct, cash_pct, other_pct)], 
                label='其他', alpha=0.7, color='red')

ax.set_xlabel('日期')
ax.set_ylabel('资产占比(%)')
ax.set_title('资产分布时间')
ax.legend(loc='upper left')
ax.set_ylim(0, 100)
ax.grid(True, alpha=0.3)

plt.xticks(rotation=45)
plt.tight_layout()
plt.savefig('资产分布时间图.png', dpi=300, bbox_inches='tight')
```

---

### 2.3 期末分布表

#### 位置和布局
- **位置**：资产分布时间图下方
- **布局**：表格形式，显示资产和负债的明细

#### 需要的数据

##### 2.3.1 资产明细
- **股票**：期末持仓市值
- **债券**：债券市值（通常为0）
- **逆回购**：逆回购金额（通常为0）
- **期货**：期货保证金/市值（通常为0）
- **期权**：期权市值（通常为0）
- **银行理财**：理财产品金额（通常为0）
- **其他证券**：其他证券市值（通常为0）
- **现金**：现金余额
- **其他资产**：其他资产（通常为0）

##### 2.3.2 负债明细
- **正回购**：正回购负债（通常为0）
  - 注意：这是负债项，不是资产项的逆回购
- **短期借款**：短期借款（通常为0）
- **融资融券**：融资融券负债（通常为0）
- **其他负债**：其他负债（如有）
  - 从账户余额或交割单中计算
  - 示例：其他负债 = 资产总值 - 资产净值 - 其他已知负债

##### 2.3.3 资产净值
- **资产净值** = 资产合计 - 负债合计

#### 计算逻辑
```python
# 计算期末资产和负债
# 资产
stock_value = sum([quantity * get_current_price(code) 
                   for code, quantity in final_positions.items()])
bond_value = 0
repo_value = 0
futures_value = 0
option_value = 0
bank_wealth_value = 0
other_security_value = 0
cash_value = final_cash_balance
other_asset_value = 0

total_assets = (stock_value + bond_value + repo_value + 
                futures_value + option_value + bank_wealth_value + 
                other_security_value + cash_value + other_asset_value)

# 负债
repo_liability = 0
short_loan = 0
margin_liability = 0
other_liability = 0.06  # 示例：其他负债0.06万元

total_liabilities = (repo_liability + short_loan + 
                     margin_liability + other_liability)

# 资产净值
net_assets = total_assets - total_liabilities
```

#### 实现方式
```python
# 创建期末分布表
from reportlab.platypus import Table, TableStyle

asset_data = [
    ['资产项', '资产市值(万元)', '资产占比(%)', '负债项', '负债市值(万元)', '负债占比(%)'],
    ['股票', f'{stock_value:.2f}', f'{stock_value/total_assets*100:.2f}', 
     '正回购', f'{repo_liability:.2f}', f'{repo_liability/total_liabilities*100:.2f}' if total_liabilities > 0 else '0.00'],
    ['债券', f'{bond_value:.2f}', f'{bond_value/total_assets*100:.2f}', 
     '短期借款', f'{short_loan:.2f}', f'{short_loan/total_liabilities*100:.2f}' if total_liabilities > 0 else '0.00'],
    # ... 更多行
    ['现金', f'{cash_value:.2f}', f'{cash_value/total_assets*100:.2f}', 
     '融资融券', f'{margin_liability:.2f}', f'{margin_liability/total_liabilities*100:.2f}' if total_liabilities > 0 else '0.00'],
    ['其他资产', f'{other_asset_value:.2f}', f'{other_asset_value/total_assets*100:.2f}', 
     '其他负债', f'{other_liability:.2f}', f'{other_liability/total_liabilities*100:.2f}' if total_liabilities > 0 else '0.00'],
    ['资产合计', f'{total_assets:.2f}', '100.00', 
     '负债合计', f'{total_liabilities:.2f}', '100.00'],
    ['资产净值', f'{net_assets:.2f}', '', '', '', '']
]

table = Table(asset_data, colWidths=[3*cm, 3*cm, 3*cm, 3*cm, 3*cm, 3*cm])
table.setStyle(TableStyle([
    ('BACKGROUND', (0, 0), (-1, 0), colors.grey),
    ('TEXTCOLOR', (0, 0), (-1, 0), colors.whitesmoke),
    ('ALIGN', (0, 0), (-1, -1), 'CENTER'),
    ('FONTNAME', (0, 0), (-1, 0), 'SimHei'),
    ('FONTSIZE', (0, 0), (-1, 0), 12),
    ('GRID', (0, 0), (-1, -1), 1, colors.black),
    ('BACKGROUND', (0, 1), (-1, -2), colors.beige),
    ('BACKGROUND', (0, -2), (-1, -2), colors.lightblue),
    ('BACKGROUND', (0, -1), (-1, -1), colors.lightgreen)
]))
```

---

### 2.4 股票仓位时序图

#### 位置和布局
- **位置**：期末分布表下方
- **布局**：双Y轴折线图，左Y轴显示股票仓位和TOP10仓位，右Y轴显示沪深300指数

#### 需要的数据

##### 2.4.1 股票仓位数据
- **数据来源**：
  - 计算每日的股票仓位
  - 股票仓位 = 股票市值 / 总资产 × 100%
- **计算逻辑**：
  ```python
  # 计算每日股票仓位
  daily_stock_position = []
  for date in date_range:
      stock_value = calculate_stock_value(date)
      total_assets = calculate_total_assets(date)
      position = stock_value / total_assets * 100 if total_assets > 0 else 0
      daily_stock_position.append((date, position))
  ```

##### 2.4.2 TOP10仓位数据
- **数据来源**：
  - 计算每日前十大持仓股票的市值占比
  - TOP10仓位 = 前十大持仓市值 / 总资产 × 100%
- **计算逻辑**：
  ```python
  # 计算每日TOP10仓位
  daily_top10_position = []
  for date in date_range:
      # 获取该日期的持仓明细
      positions_on_date = get_positions_on_date(date)
      # 按市值排序，取前10
      sorted_positions = sorted(positions_on_date.items(), 
                               key=lambda x: x[1]['market_value'], 
                               reverse=True)
      top10_value = sum([pos[1]['market_value'] for pos in sorted_positions[:10]])
      total_assets = calculate_total_assets(date)
      top10_pct = top10_value / total_assets * 100 if total_assets > 0 else 0
      daily_top10_position.append((date, top10_pct))
  ```

##### 2.4.3 沪深300指数数据
- **数据来源**：
  - 从Tushare获取沪深300指数的每日收盘价
  - 用于右Y轴显示

#### 实现方式
```python
# 创建股票仓位时序图
fig, ax1 = plt.subplots(figsize=(12, 6))

position_dates = [pd.to_datetime(d[0]) for d in daily_stock_position]
position_values = [d[1] for d in daily_stock_position]
top10_values = [d[1] for d in daily_top10_position]

# 左Y轴：股票仓位和TOP10仓位
ax1.plot(position_dates, position_values, 'b-', label='股票仓位', linewidth=2)
ax1.plot(position_dates, top10_values, 'g--', label='TOP10', linewidth=2)
ax1.set_xlabel('日期')
ax1.set_ylabel('股票仓位(%)', color='b')
ax1.tick_params(axis='y', labelcolor='b')
ax1.set_ylim(0, 120)
ax1.legend(loc='upper left')

# 右Y轴：沪深300指数
ax2 = ax1.twinx()
index_dates = [pd.to_datetime(d[0]) for d in index_cumulative]
index_prices = [d[1] for d in index_cumulative]
ax2.plot(index_dates, index_prices, 'r-', label='沪深300', linewidth=2, alpha=0.7)
ax2.set_ylabel('沪深300', color='r')
ax2.tick_params(axis='y', labelcolor='r')
ax2.legend(loc='upper right')

ax1.set_title('股票仓位时序')
ax1.grid(True, alpha=0.3)

plt.xticks(rotation=45)
plt.tight_layout()
plt.savefig('股票仓位时序图.png', dpi=300, bbox_inches='tight')
```

---

### 2.5 流动性资产时序图

#### 位置和布局
- **位置**：股票仓位时序图下方
- **布局**：双Y轴折线图，左Y轴显示流动性资产比例，右Y轴显示沪深300指数

#### 需要的数据

##### 2.5.1 流动性资产比例数据
- **数据来源**：
  - 计算每日的流动性资产比例
  - 流动性资产 = 现金 + 逆回购 + 其他可快速变现资产
  - 流动性资产比例 = 流动性资产 / 总资产 × 100%
- **计算逻辑**：
  ```python
  # 计算每日流动性资产比例
  daily_liquidity_ratio = []
  for date in date_range:
      # 计算流动性资产
      cash = calculate_cash_balance(date)
      repo = calculate_repo_value(date)  # 逆回购
      other_liquid = calculate_other_liquid_assets(date)  # 其他流动性资产
      liquid_assets = cash + repo + other_liquid
      
      total_assets = calculate_total_assets(date)
      liquidity_ratio = liquid_assets / total_assets * 100 if total_assets > 0 else 0
      daily_liquidity_ratio.append((date, liquidity_ratio))
  ```

##### 2.5.2 沪深300指数数据
- **数据来源**：
  - 从Tushare获取沪深300指数的每日收盘价
  - 用于右Y轴显示

#### 实现方式
```python
# 创建流动性资产时序图
fig, ax1 = plt.subplots(figsize=(12, 6))

liquidity_dates = [pd.to_datetime(d[0]) for d in daily_liquidity_ratio]
liquidity_values = [d[1] for d in daily_liquidity_ratio]

# 左Y轴：流动性资产比例
ax1.plot(liquidity_dates, liquidity_values, 'b-', label='流动性资产比例', linewidth=2)
ax1.set_xlabel('日期')
ax1.set_ylabel('流动性资产比例(%)', color='b')
ax1.tick_params(axis='y', labelcolor='b')
ax1.set_ylim(0, 100)
ax1.legend(loc='upper left')

# 右Y轴：沪深300指数
ax2 = ax1.twinx()
index_dates = [pd.to_datetime(d[0]) for d in index_cumulative]
index_prices = [d[1] for d in index_cumulative]
ax2.plot(index_dates, index_prices, 'r-', label='沪深300', linewidth=2, alpha=0.7)
ax2.set_ylabel('沪深300', color='r')
ax2.tick_params(axis='y', labelcolor='r')
ax2.legend(loc='upper right')

ax1.set_title('流动性资产时序')
ax1.grid(True, alpha=0.3)

plt.xticks(rotation=45)
plt.tight_layout()
plt.savefig('流动性资产时序图.png', dpi=300, bbox_inches='tight')
```

---

## 三、第三页：行业分析与绩效归因

### 3.1 持股行业分析

#### 位置和布局
- **位置**：页面顶部
- **布局**：包含多个图表和表格
  - 期末市值占比图（前十大行业占比、剩余行业）
  - 期末持股行业风格表格
  - 持股行业占比时序图
  - 持股行业偏离度时序图

#### 需要的数据

##### 3.1.1 期末市值占比
- **数据来源**：
  - 计算报告期末各行业的持仓市值
  - 按行业聚合持仓股票的市值
  - 按市值排序，取前十大行业
- **计算逻辑**：
  ```python
  # 按行业聚合持仓市值
  industry_market_values = {}
  for pos in position_details:
      industry = industry_mapping.get(pos['code'], '未知行业')
      if industry not in industry_market_values:
          industry_market_values[industry] = 0
      industry_market_values[industry] += pos['market_value']
  
  # 按市值排序，取前十大
  sorted_industries = sorted(industry_market_values.items(), 
                             key=lambda x: x[1], 
                             reverse=True)
  top10_industries = sorted_industries[:10]
  remaining_value = sum([v for _, v in sorted_industries[10:]])
  
  # 计算期间平均市值占产品净资产比
  # 需要计算每个行业在报告期间的平均持仓市值
  industry_avg_values = {}
  for industry in industry_market_values.keys():
      daily_industry_values = []
      for date in date_range:
          positions_on_date = get_positions_on_date(date)
          industry_value = sum([pos['market_value'] 
                              for pos in positions_on_date 
                              if industry_mapping.get(pos['code']) == industry])
          daily_industry_values.append(industry_value)
      avg_value = sum(daily_industry_values) / len(daily_industry_values) if daily_industry_values else 0
      industry_avg_values[industry] = avg_value
  
  # 计算期间平均市值占产品净资产比
  for industry in industry_avg_values:
      avg_pct = industry_avg_values[industry] / avg_net_assets * 100
      industry_avg_values[industry] = avg_pct
  ```

##### 3.1.2 期末持股行业风格
- **需要计算的数据**：
  - **组合PE**：组合的市盈率（加权平均）
  - **组合PB**：组合的市净率（加权平均）
  - **行业平均PE**：行业平均市盈率（从Tushare或Wind获取）
  - **行业平均PB**：行业平均市净率（从Tushare或Wind获取）
- **计算逻辑**：
  ```python
  # 计算组合PE和PB（需要从Tushare获取个股PE、PB）
  for industry in top_industries:
      industry_stocks = [pos for pos in position_details 
                        if industry_mapping.get(pos['code']) == industry]
      
      # 计算加权平均PE
      total_mv = sum([s['market_value'] for s in industry_stocks])
      weighted_pe = sum([s['market_value'] * get_pe(s['code']) / total_mv 
                        for s in industry_stocks])
      
      # 计算加权平均PB
      weighted_pb = sum([s['market_value'] * get_pb(s['code']) / total_mv 
                        for s in industry_stocks])
      
      # 获取行业平均PE、PB（从Tushare的行业数据接口获取）
      industry_avg_pe = get_industry_avg_pe(industry)
      industry_avg_pb = get_industry_avg_pb(industry)
  ```

##### 3.1.3 持股行业占比时序
- **数据来源**：
  - 计算每日各行业的持仓占比
  - 需要按日计算持仓明细，然后按行业聚合
- **计算逻辑**：
  ```python
  # 计算每日行业占比时序
  daily_industry_pct = {}
  for date in date_range:
      positions_on_date = get_positions_on_date(date)
      industry_dist = {}
      for code, pos_data in positions_on_date.items():
          industry = industry_mapping.get(code, '未知行业')
          if industry not in industry_dist:
              industry_dist[industry] = 0
          industry_dist[industry] += pos_data['market_value']
      
      total_mv = sum(industry_dist.values())
      for industry, mv in industry_dist.items():
          pct = mv / total_mv * 100 if total_mv > 0 else 0
          if industry not in daily_industry_pct:
              daily_industry_pct[industry] = []
          daily_industry_pct[industry].append((date, pct))
  ```

##### 3.1.4 持股行业偏离度时序
- **数据来源**：
  - 计算产品相对基准的所有行业偏离度绝对值的平均值
  - 需要基准指数的行业分布数据
- **计算逻辑**：
  ```python
  # 计算行业偏离度
  def calculate_industry_deviation(product_industry_dist, benchmark_industry_dist):
      """
      product_industry_dist: {行业: 占比}
      benchmark_industry_dist: {行业: 占比}
      """
      all_industries = set(product_industry_dist.keys()) | set(benchmark_industry_dist.keys())
      deviations = []
      for industry in all_industries:
          product_pct = product_industry_dist.get(industry, 0)
          benchmark_pct = benchmark_industry_dist.get(industry, 0)
          deviation = abs(product_pct - benchmark_pct)
          deviations.append(deviation)
      return sum(deviations) / len(deviations) if deviations else 0
  
  # 计算每日行业偏离度
  daily_industry_deviation = []
  for date in date_range:
      product_dist = get_industry_distribution_on_date(date, 'product')
      benchmark_dist = get_industry_distribution_on_date(date, 'benchmark')
      deviation = calculate_industry_deviation(product_dist, benchmark_dist)
      daily_industry_deviation.append((date, deviation))
  ```

#### 实现方式

##### 期末市值占比图
```python
# 创建期末市值占比图
fig, ax = plt.subplots(figsize=(12, 6))

industries = [item[0] for item in top10_industries]
values = [item[1] for item in top10_industries]
values.append(remaining_value)
industries.append('剩余行业')

colors = plt.cm.Set3(range(len(industries)))
bars = ax.barh(industries, values, color=colors)
ax.set_xlabel('持仓市值(万元)')
ax.set_title('期末市值占比 - 前十大行业')
ax.grid(True, axis='x', alpha=0.3)

# 添加数值标签
for i, (bar, val) in enumerate(zip(bars, values)):
    width = bar.get_width()
    ax.text(width, bar.get_y() + bar.get_height()/2, 
            f'{val:.2f}万元', ha='left', va='center')

plt.tight_layout()
plt.savefig('期末市值占比图.png', dpi=300, bbox_inches='tight')
```

##### 持股行业占比时序图
```python
# 创建持股行业占比时序图
fig, ax = plt.subplots(figsize=(14, 8))

# 获取主要行业（前10个）
main_industries = sorted_industries[:10]

# 堆叠面积图
dates = [pd.to_datetime(d[0]) for d in daily_industry_pct[main_industries[0][0]]]

# 按行业绘制堆叠面积
bottom = [0] * len(dates)
for industry, _ in main_industries:
    if industry in daily_industry_pct:
        values = [d[1] for d in daily_industry_pct[industry]]
        ax.fill_between(dates, bottom, [b+v for b,v in zip(bottom, values)], 
                       label=industry, alpha=0.7)
        bottom = [b+v for b,v in zip(bottom, values)]

ax.set_xlabel('日期')
ax.set_ylabel('行业占比(%)')
ax.set_title('持股行业占比时序')
ax.legend(loc='upper left', bbox_to_anchor=(1, 1))
ax.set_ylim(0, 100)
ax.grid(True, alpha=0.3)

plt.xticks(rotation=45)
plt.tight_layout()
plt.savefig('持股行业占比时序图.png', dpi=300, bbox_inches='tight')
```

##### 持股行业偏离度时序图
```python
# 创建持股行业偏离度时序图
fig, ax = plt.subplots(figsize=(12, 6))

dates = [pd.to_datetime(d[0]) for d in daily_industry_deviation]
deviations = [d[1] for d in daily_industry_deviation]

ax.plot(dates, deviations, 'b-', linewidth=2)
ax.fill_between(dates, 0, deviations, alpha=0.3, color='blue')
ax.set_xlabel('日期')
ax.set_ylabel('持股行业偏离度(%)')
ax.set_title('持股行业偏离度时序')
ax.grid(True, alpha=0.3)

plt.xticks(rotation=45)
plt.tight_layout()
plt.savefig('持股行业偏离度时序图.png', dpi=300, bbox_inches='tight')
```

##### 期末持股行业风格表格
```python
# 创建期末持股行业风格表格
table_data = [
    ['分类', '组合PE', '组合PB', '行业平均PE', '行业平均PB', '持仓市值(万元)', '占比(%)']
]

for industry, data in industry_style_data.items():
    table_data.append([
        industry,
        f"{data['portfolio_pe']:.2f}",
        f"{data['portfolio_pb']:.2f}",
        f"{data['industry_avg_pe']:.2f}",
        f"{data['industry_avg_pb']:.2f}",
        f"{data['market_value']:.2f}",
        f"{data['percentage']:.2f}"
    ])

table = Table(table_data, colWidths=[2.5*cm, 2*cm, 2*cm, 2*cm, 2*cm, 2.5*cm, 2*cm])
table.setStyle(TableStyle([
    ('BACKGROUND', (0, 0), (-1, 0), colors.grey),
    ('TEXTCOLOR', (0, 0), (-1, 0), colors.whitesmoke),
    ('ALIGN', (0, 0), (-1, -1), 'CENTER'),
    ('FONTNAME', (0, 0), (-1, 0), 'SimHei'),
    ('FONTSIZE', (0, 0), (-1, 0), 9),
    ('GRID', (0, 0), (-1, -1), 1, colors.black),
    ('BACKGROUND', (0, 1), (-1, -1), colors.beige)
]))
```

---

### 3.2 大类资产绩效归因

#### 位置和布局
- **位置**：持股行业分析下方
- **布局**：表格形式，显示各类资产的绩效贡献

#### 需要的数据

##### 3.2.1 资产类别绩效数据
- **资产类别**：股票、公募基金、逆回购等
- **权重占净值比(%)**：该资产类别占净值的比例
- **单位净值增长贡献(%)**：该资产类别对单位净值增长的贡献
- **收益率(%)**：该资产类别的收益率
- **收益额(万元)**：该资产类别的绝对收益额
- **收益额贡献率(%)**：该资产类别的收益额占总收益的比例

#### 计算逻辑
```python
# 计算大类资产绩效归因
asset_performance = []
total_profit = 0

# 股票资产
stock_weight = stock_value / net_assets * 100
stock_return = calculate_stock_return()  # 计算股票组合收益率
stock_profit = stock_value * stock_return / 100
stock_contribution = stock_profit / initial_capital * 100
total_profit += stock_profit

# 公募基金资产（如果有）
fund_weight = fund_value / net_assets * 100 if fund_value > 0 else 0
fund_return = calculate_fund_return() if fund_value > 0 else 0
fund_profit = fund_value * fund_return / 100 if fund_value > 0 else 0
fund_contribution = fund_profit / initial_capital * 100 if fund_value > 0 else 0
total_profit += fund_profit

# 逆回购资产
repo_weight = repo_value / net_assets * 100 if repo_value > 0 else 0
repo_return = calculate_repo_return() if repo_value > 0 else 0
repo_profit = repo_value * repo_return / 100 if repo_value > 0 else 0
repo_contribution = repo_profit / initial_capital * 100 if repo_value > 0 else 0

# 组织资产绩效数据
asset_performance = [
    {
        'asset_class': '股票',
        'weight': stock_weight,
        'contribution': stock_contribution,
        'return': stock_return,
        'profit': stock_profit,
        'contribution_rate': stock_profit / total_profit * 100 if total_profit > 0 else 0
    }
]

if fund_value > 0:
    asset_performance.append({
        'asset_class': '公募基金',
        'weight': fund_weight,
        'contribution': fund_contribution,
        'return': fund_return,
        'profit': fund_profit,
        'contribution_rate': fund_profit / total_profit * 100 if total_profit > 0 else 0
    })

if repo_value > 0:
    asset_performance.append({
        'asset_class': '逆回购',
        'weight': repo_weight,
        'contribution': repo_contribution,
        'return': repo_return,
        'profit': repo_profit,
        'contribution_rate': repo_profit / total_profit * 100 if total_profit > 0 else 0
    })
```

#### 实现方式
```python
# 创建大类资产绩效归因表格
from reportlab.platypus import Table, TableStyle
from reportlab.lib import colors

table_data = [
    ['资产类别', '权重占净值比(%)', '单位净值增长贡献(%)', 
     '收益率(%)', '收益额(万元)', '收益额贡献率(%)']
]

for asset in asset_performance:
    table_data.append([
        asset['asset_class'],
        f"{asset['weight']:.2f}",
        f"{asset['contribution']:.2f}",
        f"{asset['return']:.2f}",
        f"{asset['profit']:.2f}",
        f"{asset['contribution_rate']:.2f}"
    ])

# 添加合计行
total_weight = sum([a['weight'] for a in asset_performance])
total_contribution = sum([a['contribution'] for a in asset_performance])
total_profit_sum = sum([a['profit'] for a in asset_performance])

table_data.append([
    '合计',
    f"{total_weight:.2f}",
    f"{total_contribution:.2f}",
    '',  # 合计行不显示收益率
    f"{total_profit_sum:.2f}",
    '100.00'
])

table = Table(table_data, colWidths=[2.5*cm, 2.5*cm, 2.5*cm, 2.5*cm, 2.5*cm, 2.5*cm])
table.setStyle(TableStyle([
    ('BACKGROUND', (0, 0), (-1, 0), colors.grey),
    ('TEXTCOLOR', (0, 0), (-1, 0), colors.whitesmoke),
    ('ALIGN', (0, 0), (-1, -1), 'CENTER'),
    ('FONTNAME', (0, 0), (-1, 0), 'SimHei'),
    ('FONTSIZE', (0, 0), (-1, 0), 10),
    ('GRID', (0, 0), (-1, -1), 1, colors.black),
    ('BACKGROUND', (0, 1), (-1, -2), colors.beige),
    ('BACKGROUND', (0, -1), (-1, -1), colors.lightblue),
    ('FONTSIZE', (0, 1), (-1, -1), 9)
]))
```

---

## 四、第四页：Brinson归因与行业归因

### 4.1 Brinson归因

#### 位置和布局
- **位置**：页面顶部
- **布局**：折线图+表格，显示选择收益和配置收益的时序图，以及归因分析结果

#### 需要的数据

##### 4.1.1 Brinson归因概念
- **选择收益（Selection Effect）**：个股选择带来的超额收益
- **配置收益（Allocation Effect）**：行业配置带来的超额收益
- **总超额收益** = 选择收益 + 配置收益

#### 计算逻辑
```python
# Brinson归因计算
def brinson_attribution(product_returns, benchmark_returns, industry_weights):
    """
    计算Brinson归因
    
    Brinson模型将超额收益分解为：
    1. 配置收益（Allocation Effect）：由于行业配置偏离基准带来的收益
    2. 选择收益（Selection Effect）：由于个股选择带来的收益
    
    公式：
    配置收益 = Σ((Wp_i - Wb_i) × Rb_i)
    选择收益 = Σ(Wp_i × (Rp_i - Rb_i))
    
    其中：
    Wp_i = 产品在行业i的权重
    Wb_i = 基准在行业i的权重
    Rp_i = 产品在行业i的收益率
    Rb_i = 基准在行业i的收益率
    """
    # 获取基准行业权重
    benchmark_weights = get_benchmark_industry_weights()
    
    selection_effect = 0
    allocation_effect = 0
    
    for industry in industry_weights:
        # 计算产品在该行业的收益率
        product_industry_return = calculate_industry_return(product_holdings, industry)
        
        # 计算基准在该行业的收益率
        benchmark_industry_return = calculate_industry_return(benchmark_holdings, industry)
        
        # 获取权重
        product_weight = industry_weights[industry]
        benchmark_weight = benchmark_weights.get(industry, 0)
        
        # 配置收益 = Σ((行业权重 - 基准行业权重) × 基准行业收益率)
        allocation_effect += (product_weight - benchmark_weight) * benchmark_industry_return
        
        # 选择收益 = Σ(行业权重 × (行业收益率 - 基准行业收益率))
        selection_effect += product_weight * (product_industry_return - benchmark_industry_return)
    
    return selection_effect, allocation_effect

# 计算每日的Brinson归因
def calculate_brinson_on_date(date):
    """
    计算指定日期的Brinson归因
    """
    # 获取该日期的持仓和基准数据
    product_holdings = get_positions_on_date(date)
    benchmark_holdings = get_benchmark_holdings_on_date(date)
    
    # 计算行业权重
    industry_weights = calculate_industry_weights(product_holdings)
    
    # 计算Brinson归因
    selection, allocation = brinson_attribution(product_holdings, benchmark_holdings, industry_weights)
    
    return selection, allocation
```

##### 4.1.2 个股选择收益和行业配置收益
- **个股选择收益(%)**：所有行业的个股选择收益之和
- **行业配置收益(%)**：所有行业的行业配置收益之和

#### 实现方式
```python
# 创建Brinson归因图
fig, ax = plt.subplots(figsize=(12, 6))

# 计算每日的选择收益和配置收益
daily_selection = []
daily_allocation = []
for date in date_range:
    selection_ret, allocation_ret = calculate_brinson_on_date(date)
    daily_selection.append((date, selection_ret))
    daily_allocation.append((date, allocation_ret))

# 计算累计收益
cumulative_selection = []
cumulative_allocation = []
cum_sel = 0
cum_allo = 0
for date, sel_ret in daily_selection:
    cum_sel += sel_ret
    cumulative_selection.append((date, cum_sel))

for date, allo_ret in daily_allocation:
    cum_allo += allo_ret
    cumulative_allocation.append((date, cum_allo))

dates = [pd.to_datetime(d[0]) for d in cumulative_selection]
sel_values = [d[1] for d in cumulative_selection]
allo_values = [d[1] for d in cumulative_allocation]

ax.plot(dates, sel_values, 'b-', label='选择收益', linewidth=2)
ax.plot(dates, allo_values, 'r--', label='配置收益', linewidth=2)
ax.set_xlabel('日期')
ax.set_ylabel('累计收益率(%)')
ax.set_title('Brinson归因')
ax.legend()
ax.grid(True, alpha=0.3)

plt.xticks(rotation=45)
plt.tight_layout()
plt.savefig('Brinson归因图.png', dpi=300, bbox_inches='tight')
```

---

### 4.2 股票行业归因

#### 位置和布局
- **位置**：Brinson归因下方
- **布局**：两个表格，分别显示按照收益额排名前十和按照亏损额排名前十的行业

#### 需要的数据

##### 4.2.1 行业归因数据
- **行业**：行业名称
- **权重占净值比(%)**：该行业在组合中的权重
- **贡献度(%)**：该行业对总收益的贡献度
- **收益额(万元)**：该行业的绝对收益额
- **选择收益(%)**：该行业的个股选择收益
- **配置收益(%)**：该行业的行业配置收益

#### 计算逻辑
```python
# 计算每个行业的归因
industry_attribution = []
for industry in industries:
    # 计算该行业的持仓
    industry_stocks = [pos for pos in position_details 
                      if industry_mapping.get(pos['code']) == industry]
    
    # 计算行业权重
    industry_weight = sum([s['market_value'] for s in industry_stocks]) / total_assets * 100
    
    # 计算行业收益额
    industry_profit = sum([s['profit_loss'] for s in industry_stocks])
    
    # 计算贡献度
    contribution = industry_profit / total_profit * 100 if total_profit > 0 else 0
    
    # 计算选择收益和配置收益（使用Brinson模型）
    selection_ret, allocation_ret = calculate_brinson_for_industry(industry, industry_stocks)
    
    industry_attribution.append({
        'industry': industry,
        'weight': industry_weight,
        'contribution': contribution,
        'profit': industry_profit,
        'selection_return': selection_ret,
        'allocation_return': allocation_ret
    })

# 按收益额排序
sorted_by_profit = sorted(industry_attribution, key=lambda x: x['profit'], reverse=True)
top10_profit = sorted_by_profit[:10]
top10_loss = sorted_by_profit[-10:]  # 亏损最多的10个
```

#### 实现方式
```python
# 创建股票行业归因表格
# 按照收益额排名前十
profit_table_data = [
    ['行业', '权重占净值比(%)', '贡献度(%)', '收益额(万元)', '选择收益(%)', '配置收益(%)']
]

for industry_data in top10_profit:
    profit_table_data.append([
        industry_data['industry'],
        f"{industry_data['weight']:.2f}",
        f"{industry_data['contribution']:.2f}",
        f"{industry_data['profit']:.2f}",
        f"{industry_data['selection_return']:.2f}",
        f"{industry_data['allocation_return']:.2f}"
    ])

profit_table = Table(profit_table_data, colWidths=[2.5*cm, 2*cm, 2*cm, 2.5*cm, 2*cm, 2*cm])
profit_table.setStyle(TableStyle([
    ('BACKGROUND', (0, 0), (-1, 0), colors.grey),
    ('TEXTCOLOR', (0, 0), (-1, 0), colors.whitesmoke),
    ('ALIGN', (0, 0), (-1, -1), 'CENTER'),
    ('FONTNAME', (0, 0), (-1, 0), 'SimHei'),
    ('FONTSIZE', (0, 0), (-1, 0), 9),
    ('GRID', (0, 0), (-1, -1), 1, colors.black),
    ('BACKGROUND', (0, 1), (-1, -1), colors.beige)
]))

# 按照亏损额排名前十
loss_table_data = [
    ['行业', '权重占净值比(%)', '贡献度(%)', '收益额(万元)', '选择收益(%)', '配置收益(%)']
]

for industry_data in top10_loss:
    loss_table_data.append([
        industry_data['industry'],
        f"{industry_data['weight']:.2f}",
        f"{industry_data['contribution']:.2f}",
        f"{industry_data['profit']:.2f}",
        f"{industry_data['selection_return']:.2f}",
        f"{industry_data['allocation_return']:.2f}"
    ])

loss_table = Table(loss_table_data, colWidths=[2.5*cm, 2*cm, 2*cm, 2.5*cm, 2*cm, 2*cm])
loss_table.setStyle(TableStyle([
    ('BACKGROUND', (0, 0), (-1, 0), colors.grey),
    ('TEXTCOLOR', (0, 0), (-1, 0), colors.whitesmoke),
    ('ALIGN', (0, 0), (-1, -1), 'CENTER'),
    ('FONTNAME', (0, 0), (-1, 0), 'SimHei'),
    ('FONTSIZE', (0, 0), (-1, 0), 9),
    ('GRID', (0, 0), (-1, -1), 1, colors.black),
    ('BACKGROUND', (0, 1), (-1, -1), colors.beige)
]))
```

---

## 五、第五页：股票绩效归因与期货归因

### 5.1 股票绩效归因

#### 位置和布局
- **位置**：页面顶部
- **布局**：两个表格，分别显示盈利前十和亏损前十的股票

#### 需要的数据

##### 5.1.1 股票绩效数据
- **股票代码**：6位股票代码
- **股票名称**：股票中文名称
- **权重占净值比(%)**：该股票在组合中的权重
- **贡献度(%)**：该股票对总收益的贡献度
- **收益额(万元)**：该股票的绝对收益额

#### 计算逻辑
```python
# 计算每只股票的绩效
stock_performance = []
for pos in position_details:
    weight = pos['market_value'] / total_assets * 100
    contribution = pos['profit_loss'] / total_profit * 100 if total_profit > 0 else 0
    
    stock_performance.append({
        'code': pos['code'],
        'name': pos['name'],
        'weight': weight,
        'contribution': contribution,
        'profit': pos['profit_loss']
    })

# 按收益额排序
sorted_by_profit = sorted(stock_performance, key=lambda x: x['profit'], reverse=True)
top10_profit = sorted_by_profit[:10]
top10_loss = sorted_by_profit[-10:]  # 亏损最多的10只
```

#### 实现方式
```python
# 创建股票绩效归因表格
# 盈利前十表格
profit_table_data = [
    ['股票代码', '股票名称', '权重占净值比(%)', '贡献度(%)', '收益额(万元)']
]

for stock in top10_profit:
    profit_table_data.append([
        stock['code'],
        stock['name'],
        f"{stock['weight']:.2f}",
        f"{stock['contribution']:.2f}",
        f"{stock['profit']:.2f}"
    ])

profit_table = Table(profit_table_data, colWidths=[2*cm, 3*cm, 2.5*cm, 2.5*cm, 2.5*cm])
profit_table.setStyle(TableStyle([
    ('BACKGROUND', (0, 0), (-1, 0), colors.grey),
    ('TEXTCOLOR', (0, 0), (-1, 0), colors.whitesmoke),
    ('ALIGN', (0, 0), (-1, -1), 'CENTER'),
    ('FONTNAME', (0, 0), (-1, 0), 'SimHei'),
    ('FONTSIZE', (0, 0), (-1, 0), 9),
    ('GRID', (0, 0), (-1, -1), 1, colors.black),
    ('BACKGROUND', (0, 1), (-1, -1), colors.beige)
]))

# 亏损前十表格
loss_table_data = [
    ['股票代码', '股票名称', '权重占净值比(%)', '贡献度(%)', '收益额(万元)']
]

for stock in top10_loss:
    loss_table_data.append([
        stock['code'],
        stock['name'],
        f"{stock['weight']:.2f}",
        f"{stock['contribution']:.2f}",
        f"{stock['profit']:.2f}"
    ])

loss_table = Table(loss_table_data, colWidths=[2*cm, 3*cm, 2.5*cm, 2.5*cm, 2.5*cm])
loss_table.setStyle(TableStyle([
    ('BACKGROUND', (0, 0), (-1, 0), colors.grey),
    ('TEXTCOLOR', (0, 0), (-1, 0), colors.whitesmoke),
    ('ALIGN', (0, 0), (-1, -1), 'CENTER'),
    ('FONTNAME', (0, 0), (-1, 0), 'SimHei'),
    ('FONTSIZE', (0, 0), (-1, 0), 9),
    ('GRID', (0, 0), (-1, -1), 1, colors.black),
    ('BACKGROUND', (0, 1), (-1, -1), colors.beige)
]))
```

---

### 5.2 个股持仓节点

#### 位置和布局
- **位置**：股票绩效归因下方
- **布局**：柱状图，显示TOP1、TOP2、TOP3、TOP5、TOP10、TOP50、TOP100的持仓市值和占比

#### 需要的数据

##### 5.2.1 持仓节点数据
- **TOP1个股**：第一大持仓的市值和占比
- **TOP2个股**：前两大持仓的累计市值和占比
- **TOP3个股**：前三大持仓的累计市值和占比
- **TOP5个股**：前五大持仓的累计市值和占比
- **TOP10个股**：前十大持仓的累计市值和占比
- **TOP50个股**：前五十大持仓的累计市值和占比
- **TOP100个股**：前一百大持仓的累计市值和占比

#### 计算逻辑
```python
# 计算持仓节点
sorted_positions = sorted(position_details, 
                         key=lambda x: x['market_value'], 
                         reverse=True)

nodes = {
    'TOP1': sorted_positions[0:1],
    'TOP2': sorted_positions[0:2],
    'TOP3': sorted_positions[0:3],
    'TOP5': sorted_positions[0:5],
    'TOP10': sorted_positions[0:10],
    'TOP50': sorted_positions[0:50],
    'TOP100': sorted_positions[0:100]
}

node_data = []
for node_name, stocks in nodes.items():
    total_mv = sum([s['market_value'] for s in stocks])
    total_pct = total_mv / total_assets * 100
    node_data.append({
        'node': node_name,
        'market_value': total_mv,
        'percentage': total_pct
    })
```

#### 实现方式
```python
# 创建个股持仓节点图
fig, ax1 = plt.subplots(figsize=(12, 6))

node_names = [d['node'] for d in node_data]
market_values = [d['market_value'] for d in node_data]
percentages = [d['percentage'] for d in node_data]

# 左Y轴：市值
bars = ax1.bar(node_names, market_values, alpha=0.7, color='blue', label='市值(万元)')
ax1.set_xlabel('持仓节点')
ax1.set_ylabel('市值(万元)', color='b')
ax1.tick_params(axis='y', labelcolor='b')
ax1.legend(loc='upper left')

# 右Y轴：占比
ax2 = ax1.twinx()
ax2.plot(node_names, percentages, 'r-o', linewidth=2, markersize=8, label='占比(%)')
ax2.set_ylabel('占比(%)', color='r')
ax2.tick_params(axis='y', labelcolor='r')
ax2.legend(loc='upper right')

ax1.set_title('个股持仓节点')
ax1.grid(True, alpha=0.3, axis='y')

plt.tight_layout()
plt.savefig('个股持仓节点图.png', dpi=300, bbox_inches='tight')
```

---

### 5.3 期货分类归因

#### 位置和布局
- **位置**：个股持仓节点下方
- **布局**：表格形式，显示各类期货的绩效归因

#### 需要的数据

##### 5.3.1 期货分类数据
- **资产分类**：股指期货、商品期货、国债期货
- **权重(占净值比%)**：该类别期货的权重
- **单位净值增长贡献(%)**：对单位净值增长的贡献
- **收益率(%)**：该类别期货的收益率
- **费前收益额(万元)**：费用前的收益额
- **费后收益额(万元)**：费用后的收益额
- **收益额贡献率(%)**：收益额贡献率

#### 计算逻辑
```python
# 计算期货分类归因（如果有期货持仓）
futures_categories = {
    '股指期货': calculate_futures_value('stock_index'),
    '商品期货': calculate_futures_value('commodity'),
    '国债期货': calculate_futures_value('bond')
}

futures_category_data = []
for category, value in futures_categories.items():
    if value > 0:
        weight = value / net_assets * 100
        return_rate = calculate_futures_return(category)
        profit_before_fee = value * return_rate / 100
        profit_after_fee = profit_before_fee - futures_fees
        contribution = profit_after_fee / initial_capital * 100
        contribution_rate = profit_after_fee / total_profit * 100 if total_profit > 0 else 0
        
        futures_category_data.append({
            'category': category,
            'weight': weight,
            'contribution': contribution,
            'return': return_rate,
            'profit_before_fee': profit_before_fee,
            'profit_after_fee': profit_after_fee,
            'contribution_rate': contribution_rate
        })
```

#### 实现方式
```python
# 创建期货分类归因表格
table_data = [
    ['资产分类', '权重(占净值比%)', '单位净值增长贡献(%)', 
     '收益率(%)', '费前收益额(万元)', '费后收益额(万元)', '收益额贡献率(%)']
]

for category_data in futures_category_data:
    table_data.append([
        category_data['category'],
        f"{category_data['weight']:.2f}",
        f"{category_data['contribution']:.2f}",
        f"{category_data['return']:.2f}",
        f"{category_data['profit_before_fee']:.2f}",
        f"{category_data['profit_after_fee']:.2f}",
        f"{category_data['contribution_rate']:.2f}"
    ])

# 如果没有期货持仓，显示提示信息
if len(futures_category_data) == 0:
    table_data.append(['暂无期货持仓', '', '', '', '', '', ''])

table = Table(table_data, colWidths=[2.5*cm, 2*cm, 2.5*cm, 2*cm, 2.5*cm, 2.5*cm, 2*cm])
table.setStyle(TableStyle([
    ('BACKGROUND', (0, 0), (-1, 0), colors.grey),
    ('TEXTCOLOR', (0, 0), (-1, 0), colors.whitesmoke),
    ('ALIGN', (0, 0), (-1, -1), 'CENTER'),
    ('FONTNAME', (0, 0), (-1, 0), 'SimHei'),
    ('FONTSIZE', (0, 0), (-1, 0), 9),
    ('GRID', (0, 0), (-1, -1), 1, colors.black),
    ('BACKGROUND', (0, 1), (-1, -1), colors.beige)
]))
```

---

### 5.4 期货板块归因

#### 位置和布局
- **位置**：期货分类归因下方
- **布局**：图表+表格，显示各期货板块的归因

#### 需要的数据

##### 5.4.1 期货板块数据
- **板块分类**：贵金属、有色、煤焦钢矿、非金属建材、能源、化工、谷物、油脂油料、软商品、农副产品、集运指数、股指期货、国债期货
- **日平均多头持仓（万元）**：平均多头持仓金额
- **多头收益额（万元）**：多头持仓的收益额
- **日平均空头持仓（万元）**：平均空头持仓金额
- **空头收益额（万元）**：空头持仓的收益额
- **期间收益额（万元）**：期间总收益额
- **板块指数涨跌（%）**：板块指数的涨跌幅（从Tushare或Wind获取）

#### 计算逻辑
```python
# 计算期货板块归因（如果有期货持仓）
futures_blocks = {
    '贵金属': ['AU', 'AG'],  # 示例：黄金、白银合约代码
    '有色': ['CU', 'AL', 'ZN'],
    '煤焦钢矿': ['RB', 'HC', 'I'],
    # ... 其他板块
}

for block_name, contract_codes in futures_blocks.items():
    # 计算该板块的日平均多头和空头持仓
    daily_long = []
    daily_short = []
    long_profit = 0
    short_profit = 0
    
    for date in date_range:
        long_value = sum([get_futures_position(code, date, 'long') 
                         for code in contract_codes])
        short_value = sum([get_futures_position(code, date, 'short') 
                          for code in contract_codes])
        daily_long.append(long_value)
        daily_short.append(short_value)
    
    avg_long = sum(daily_long) / len(daily_long) if daily_long else 0
    avg_short = sum(daily_short) / len(daily_short) if daily_short else 0
    
    # 计算收益额
    long_profit = calculate_futures_profit(contract_codes, 'long')
    short_profit = calculate_futures_profit(contract_codes, 'short')
    total_profit = long_profit + short_profit
    
    # 获取板块指数涨跌（从Tushare获取板块指数数据）
    block_index_change = get_block_index_change(block_name, start_date, end_date)
```

#### 实现方式
```python
# 创建期货板块归因表格
table_data = [
    ['板块', '日平均多头持仓(万元)', '多头收益额(万元)', 
     '日平均空头持仓(万元)', '空头收益额(万元)', 
     '期间收益额(万元)', '板块指数涨跌(%)']
]

for block_name, block_data in futures_block_data.items():
    table_data.append([
        block_name,
        f"{block_data['avg_long']:.2f}",
        f"{block_data['long_profit']:.2f}",
        f"{block_data['avg_short']:.2f}",
        f"{block_data['short_profit']:.2f}",
        f"{block_data['total_profit']:.2f}",
        f"{block_data['index_change']:.2f}"
    ])

table = Table(table_data, colWidths=[2.5*cm, 2.5*cm, 2.5*cm, 
                                      2.5*cm, 2.5*cm, 2.5*cm, 2.5*cm])
table.setStyle(TableStyle([
    ('BACKGROUND', (0, 0), (-1, 0), colors.grey),
    ('TEXTCOLOR', (0, 0), (-1, 0), colors.whitesmoke),
    ('ALIGN', (0, 0), (-1, -1), 'CENTER'),
    ('FONTNAME', (0, 0), (-1, 0), 'SimHei'),
    ('FONTSIZE', (0, 0), (-1, 0), 9),
    ('GRID', (0, 0), (-1, -1), 1, colors.black),
    ('BACKGROUND', (0, 1), (-1, -1), colors.beige)
]))
```

---

## 六、第六页：债券分析与交易统计

### 6.1 评级分布&久期分布

#### 位置和布局
- **位置**：页面顶部
- **布局**：图表形式，显示债券的评级分布和久期分布

#### 需要的数据

##### 6.1.1 债券评级分布
- **数据来源**：如果有债券持仓，需要获取债券的信用评级
- **评级分类**：AAA、AA+、AA、AA-等

##### 6.1.2 债券久期分布
- **组合加权修正久期**：组合的加权平均修正久期
- **久期分类**：0-1月、1-3月、3-6月、6-12月、1-3年、3-5年、5-7年、7年以上

#### 计算逻辑
```python
# 计算债券评级分布和久期分布（如果有债券持仓）
if bond_value > 0:
    bonds = get_bond_holdings()
    
    # 计算评级分布
    rating_distribution = {}
    for bond in bonds:
        rating = get_bond_rating(bond['code'])  # 从债券数据源获取评级
        if rating not in rating_distribution:
            rating_distribution[rating] = 0
        rating_distribution[rating] += bond['market_value']
    
    # 计算组合加权修正久期
    weighted_duration = 0
    duration_distribution = {
        '0-1月': 0,
        '1-3月': 0,
        '3-6月': 0,
        '6-12月': 0,
        '1-3年': 0,
        '3-5年': 0,
        '5-7年': 0,
        '7年以上': 0
    }
    
    for bond in bonds:
        duration = get_bond_duration(bond['code'])  # 获取修正久期（年）
        weight = bond['market_value'] / bond_value
        weighted_duration += duration * weight
        
        # 分类到久期区间
        if duration <= 1/12:  # 0-1月
            duration_distribution['0-1月'] += bond['market_value']
        elif duration <= 3/12:  # 1-3月
            duration_distribution['1-3月'] += bond['market_value']
        elif duration <= 6/12:  # 3-6月
            duration_distribution['3-6月'] += bond['market_value']
        elif duration <= 1:  # 6-12月
            duration_distribution['6-12月'] += bond['market_value']
        elif duration <= 3:  # 1-3年
            duration_distribution['1-3年'] += bond['market_value']
        elif duration <= 5:  # 3-5年
            duration_distribution['3-5年'] += bond['market_value']
        elif duration <= 7:  # 5-7年
            duration_distribution['5-7年'] += bond['market_value']
        else:  # 7年以上
            duration_distribution['7年以上'] += bond['market_value']
```

#### 实现方式
```python
# 创建债券评级分布图
if bond_value > 0:
    fig, (ax1, ax2) = plt.subplots(1, 2, figsize=(14, 6))
    
    # 评级分布饼图
    ratings = list(rating_distribution.keys())
    values = list(rating_distribution.values())
    colors_pie = plt.cm.Set3(range(len(ratings)))
    
    ax1.pie(values, labels=ratings, autopct='%1.1f%%', startangle=90, colors=colors_pie)
    ax1.set_title('债券评级分布', fontsize=14, fontweight='bold')
    
    # 久期分布柱状图
    duration_categories = list(duration_distribution.keys())
    duration_values = [duration_distribution[cat] for cat in duration_categories]
    
    bars = ax2.bar(duration_categories, duration_values, color='steelblue', alpha=0.7)
    ax2.set_xlabel('久期分类')
    ax2.set_ylabel('持仓市值(万元)')
    ax2.set_title(f'债券久期分布（组合加权修正久期：{weighted_duration:.2f}年）', 
                  fontsize=14, fontweight='bold')
    ax2.tick_params(axis='x', rotation=45)
    ax2.grid(True, alpha=0.3, axis='y')
    
    # 添加数值标签
    for bar, val in zip(bars, duration_values):
        if val > 0:
            height = bar.get_height()
            ax2.text(bar.get_x() + bar.get_width()/2., height,
                    f'{val:.2f}',
                    ha='center', va='bottom')
    
    plt.tight_layout()
    plt.savefig('债券评级久期分布图.png', dpi=300, bbox_inches='tight')
else:
    # 如果没有债券持仓，创建空图表或提示
    fig, ax = plt.subplots(figsize=(10, 6))
    ax.text(0.5, 0.5, '暂无债券持仓', ha='center', va='center', 
            fontsize=16, transform=ax.transAxes)
    ax.set_title('债券评级分布&久期分布', fontsize=14, fontweight='bold')
    plt.axis('off')
    plt.savefig('债券评级久期分布图.png', dpi=300, bbox_inches='tight')
```

---

### 6.2 债券行业分布

#### 位置和布局
- **位置**：评级分布下方
- **布局**：表格形式，显示债券的行业分布

#### 需要的数据
- **分类**：债券所属行业
- **持仓市值(万元)**：该行业的债券持仓市值
- **占债券资产比例(%)**：占债券资产的比例

#### 计算逻辑
```python
# 计算债券行业分布（如果有债券持仓）
if bond_value > 0:
    bonds = get_bond_holdings()
    bond_industry_distribution = {}
    
    for bond in bonds:
        industry = get_bond_industry(bond['code'])  # 从债券数据源获取行业分类
        if industry not in bond_industry_distribution:
            bond_industry_distribution[industry] = 0
        bond_industry_distribution[industry] += bond['market_value']
    
    # 计算占比
    for industry in bond_industry_distribution:
        bond_industry_distribution[industry] = {
            'market_value': bond_industry_distribution[industry],
            'percentage': bond_industry_distribution[industry] / bond_value * 100
        }
    
    # 按市值排序
    sorted_bond_industries = sorted(bond_industry_distribution.items(),
                                   key=lambda x: x[1]['market_value'],
                                   reverse=True)
```

#### 实现方式
```python
# 创建债券行业分布表格
if bond_value > 0:
    table_data = [
        ['分类', '持仓市值(万元)', '占债券资产比例(%)']
    ]
    
    for industry, data in sorted_bond_industries:
        table_data.append([
            industry,
            f"{data['market_value']:.2f}",
            f"{data['percentage']:.2f}"
        ])
    
    # 添加合计行
    total_bond_mv = sum([d['market_value'] for _, d in sorted_bond_industries])
    table_data.append([
        '合计',
        f"{total_bond_mv:.2f}",
        '100.00'
    ])
    
    table = Table(table_data, colWidths=[4*cm, 4*cm, 4*cm])
    table.setStyle(TableStyle([
        ('BACKGROUND', (0, 0), (-1, 0), colors.grey),
        ('TEXTCOLOR', (0, 0), (-1, 0), colors.whitesmoke),
        ('ALIGN', (0, 0), (-1, -1), 'CENTER'),
        ('FONTNAME', (0, 0), (-1, 0), 'SimHei'),
        ('FONTSIZE', (0, 0), (-1, 0), 10),
        ('GRID', (0, 0), (-1, -1), 1, colors.black),
        ('BACKGROUND', (0, 1), (-1, -2), colors.beige),
        ('BACKGROUND', (0, -1), (-1, -1), colors.lightblue)
    ]))
else:
    # 如果没有债券持仓，创建空表格或提示
    table_data = [
        ['分类', '持仓市值(万元)', '占债券资产比例(%)'],
        ['暂无债券持仓', '0.00', '0.00']
    ]
    table = Table(table_data, colWidths=[4*cm, 4*cm, 4*cm])
    table.setStyle(TableStyle([
        ('BACKGROUND', (0, 0), (-1, 0), colors.grey),
        ('TEXTCOLOR', (0, 0), (-1, 0), colors.whitesmoke),
        ('ALIGN', (0, 0), (-1, -1), 'CENTER'),
        ('FONTNAME', (0, 0), (-1, 0), 'SimHei'),
        ('FONTSIZE', (0, 0), (-1, 0), 10),
        ('GRID', (0, 0), (-1, -1), 1, colors.black),
        ('BACKGROUND', (0, 1), (-1, -1), colors.beige)
    ]))
```

---

### 6.3 换手率（年化）

#### 位置和布局
- **位置**：债券行业分布下方
- **布局**：表格形式，显示各资产类别的换手率

#### 需要的数据

##### 6.3.1 换手率计算
- **换手率（年化）** = (期间交易金额 / 期间平均持仓市值) × (365 / 实际天数) × 100%
- **资产分类**：股票、基金、逆回购等
- **时间段**：统计期间、近一个月、近三个月、近六个月、今年以来、成立以来

#### 计算逻辑
```python
# 计算换手率
def calculate_turnover(asset_class, period_start, period_end):
    """
    计算换手率
    """
    # 计算期间交易金额
    buy_amount = sum([t['amount'] for t in transactions 
                     if t['date'] >= period_start and t['date'] <= period_end 
                     and t['asset_class'] == asset_class and t['direction'] == '买入'])
    sell_amount = sum([t['amount'] for t in transactions 
                      if t['date'] >= period_start and t['date'] <= period_end 
                      and t['asset_class'] == asset_class and t['direction'] == '卖出'])
    total_turnover = buy_amount + sell_amount
    
    # 计算期间平均持仓市值
    avg_market_value = calculate_avg_market_value(asset_class, period_start, period_end)
    
    # 计算年化换手率
    days = (period_end - period_start).days
    turnover_rate = (total_turnover / avg_market_value) * (365 / days) * 100 if avg_market_value > 0 else 0
    
    return turnover_rate

# 计算各时间段的换手率
periods = {
    '统计期间': (report_start_date, report_end_date),
    '近一个月': (one_month_ago, report_end_date),
    '近三个月': (three_months_ago, report_end_date),
    '近六个月': (six_months_ago, report_end_date),
    '今年以来': (year_start_date, report_end_date),
    '成立以来': (establish_date, report_end_date)
}

turnover_data = {}
for asset_class in ['股票', '基金', '逆回购']:
    turnover_data[asset_class] = {}
    for period_name, (start, end) in periods.items():
        turnover_rate = calculate_turnover(asset_class, start, end)
        turnover_data[asset_class][period_name] = turnover_rate
```

#### 实现方式
```python
# 创建换手率表格
table_data = [
    ['资产分类', '统计期间(%)', '近一个月(%)', '近三个月(%)', 
     '近六个月(%)', '今年以来(%)', '成立以来(%)']
]

for asset_class in ['股票', '基金', '逆回购']:
    row = [asset_class]
    for period_name in periods.keys():
        rate = turnover_data[asset_class].get(period_name, 0)
        row.append(f"{rate:.2f}")
    table_data.append(row)

table = Table(table_data, colWidths=[2.5*cm, 2*cm, 2*cm, 2*cm, 2*cm, 2*cm, 2*cm])
table.setStyle(TableStyle([
    ('BACKGROUND', (0, 0), (-1, 0), colors.grey),
    ('TEXTCOLOR', (0, 0), (-1, 0), colors.whitesmoke),
    ('ALIGN', (0, 0), (-1, -1), 'CENTER'),
    ('FONTNAME', (0, 0), (-1, 0), 'SimHei'),
    ('FONTSIZE', (0, 0), (-1, 0), 9),
    ('GRID', (0, 0), (-1, -1), 1, colors.black),
    ('BACKGROUND', (0, 1), (-1, -1), colors.beige)
]))
```

---

### 6.4 期间交易统计

#### 位置和布局
- **位置**：换手率下方
- **布局**：图表+表格，显示各类资产的买入和卖出金额

#### 需要的数据

##### 6.4.1 交易统计数据
- **资产分类**：股票、基金、逆回购等
- **买入金额(万元)**：期间总买入金额
- **卖出金额(万元)**：期间总卖出金额

#### 计算逻辑
```python
# 计算期间交易统计
trading_stats = {}
for asset_class in ['股票', '基金', '逆回购']:
    buy_amount = sum([t['amount'] for t in transactions 
                     if t['asset_class'] == asset_class and t['direction'] == '买入'])
    sell_amount = sum([t['amount'] for t in transactions 
                      if t['asset_class'] == asset_class and t['direction'] == '卖出'])
    trading_stats[asset_class] = {
        'buy_amount': buy_amount,
        'sell_amount': sell_amount
    }
```

#### 实现方式
```python
# 创建期间交易统计图表和表格
fig, ax = plt.subplots(figsize=(12, 6))

asset_classes = ['股票', '基金', '逆回购']
buy_amounts = [trading_stats[ac]['buy_amount'] for ac in asset_classes]
sell_amounts = [trading_stats[ac]['sell_amount'] for ac in asset_classes]

x = np.arange(len(asset_classes))
width = 0.35

bars1 = ax.bar(x - width/2, buy_amounts, width, label='买入', color='green', alpha=0.7)
bars2 = ax.bar(x + width/2, sell_amounts, width, label='卖出', color='red', alpha=0.7)

ax.set_xlabel('资产分类')
ax.set_ylabel('金额(万元)')
ax.set_title('期间交易统计')
ax.set_xticks(x)
ax.set_xticklabels(asset_classes)
ax.legend()
ax.grid(True, alpha=0.3, axis='y')

plt.tight_layout()
plt.savefig('期间交易统计图.png', dpi=300, bbox_inches='tight')

# 创建期间交易统计表格
table_data = [
    ['资产分类', '买入金额(万元)', '卖出金额(万元)']
]

for asset_class in asset_classes:
    table_data.append([
        asset_class,
        f"{trading_stats[asset_class]['buy_amount']:.2f}",
        f"{trading_stats[asset_class]['sell_amount']:.2f}"
    ])

table = Table(table_data, colWidths=[3*cm, 4*cm, 4*cm])
table.setStyle(TableStyle([
    ('BACKGROUND', (0, 0), (-1, 0), colors.grey),
    ('TEXTCOLOR', (0, 0), (-1, 0), colors.whitesmoke),
    ('ALIGN', (0, 0), (-1, -1), 'CENTER'),
    ('FONTNAME', (0, 0), (-1, 0), 'SimHei'),
    ('FONTSIZE', (0, 0), (-1, 0), 10),
    ('GRID', (0, 0), (-1, -1), 1, colors.black),
    ('BACKGROUND', (0, 1), (-1, -1), colors.beige)
]))
```

---

### 6.5 前十大买卖期货

#### 位置和布局
- **位置**：期间交易统计下方
- **布局**：表格形式，显示前十大买卖期货

#### 需要的数据
- **期货品种**：期货合约名称
- **多头**：多头持仓数量和金额
  - 数量(万手)：多头持仓数量
  - 金额(万元)：多头持仓金额
- **空头**：空头持仓数量和金额
  - 数量(万股)：空头持仓数量（注意单位）
  - 金额(万元)：空头持仓金额
- **交易金额(万元)**：交易金额
- **总盈亏(万元)**：总盈亏

#### 计算逻辑
```python
# 从交割单中识别期货交易
futures_transactions = []
for trans in transactions:
    if is_futures(trans['code']):  # 判断是否为期货合约
        futures_transactions.append(trans)

# 按期货品种聚合
futures_by_code = {}
for trans in futures_transactions:
    code = trans['code']
    if code not in futures_by_code:
        futures_by_code[code] = {
            'long_quantity': 0,
            'long_amount': 0,
            'short_quantity': 0,
            'short_amount': 0,
            'total_amount': 0,
            'total_profit': 0
        }
    
    if trans['direction'] == '买入':
        futures_by_code[code]['long_quantity'] += trans['quantity']
        futures_by_code[code]['long_amount'] += trans['amount']
    elif trans['direction'] == '卖出':
        futures_by_code[code]['short_quantity'] += trans['quantity']
        futures_by_code[code]['short_amount'] += trans['amount']
    
    futures_by_code[code]['total_amount'] += trans['amount']
    futures_by_code[code]['total_profit'] += calculate_futures_profit(trans)

# 按交易金额排序，取前10
sorted_futures = sorted(futures_by_code.items(), 
                       key=lambda x: x[1]['total_amount'], 
                       reverse=True)
top10_futures = sorted_futures[:10]

# 获取期货合约名称
for code, data in top10_futures:
    data['name'] = get_futures_name(code)  # 从期货数据源获取合约名称
```

#### 实现方式
```python
# 创建前十大买卖期货表格
table_data = [
    ['期货品种', '多头\n数量(万手)', '多头\n金额(万元)', 
     '空头\n数量(万手)', '空头\n金额(万元)', 
     '交易金额(万元)', '总盈亏(万元)']
]

if len(top10_futures) > 0:
    for code, data in top10_futures:
        table_data.append([
            data.get('name', code),  # 期货合约名称
            f"{data['long_quantity']:.2f}",
            f"{data['long_amount']:.2f}",
            f"{data['short_quantity']:.2f}",
            f"{data['short_amount']:.2f}",
            f"{data['total_amount']:.2f}",
            f"{data['total_profit']:.2f}"
        ])
    
    # 添加合计行
    total_long_qty = sum([d['long_quantity'] for _, d in top10_futures])
    total_long_amt = sum([d['long_amount'] for _, d in top10_futures])
    total_short_qty = sum([d['short_quantity'] for _, d in top10_futures])
    total_short_amt = sum([d['short_amount'] for _, d in top10_futures])
    total_amt = sum([d['total_amount'] for _, d in top10_futures])
    total_profit = sum([d['total_profit'] for _, d in top10_futures])
    
    table_data.append([
        '合计',
        f"{total_long_qty:.2f}",
        f"{total_long_amt:.2f}",
        f"{total_short_qty:.2f}",
        f"{total_short_amt:.2f}",
        f"{total_amt:.2f}",
        f"{total_profit:.2f}"
    ])
else:
    table_data.append(['暂无期货交易', '', '', '', '', '', ''])

table = Table(table_data, colWidths=[2.5*cm, 1.8*cm, 1.8*cm, 1.8*cm, 1.8*cm, 2*cm, 2*cm])
table.setStyle(TableStyle([
    ('BACKGROUND', (0, 0), (-1, 0), colors.grey),
    ('TEXTCOLOR', (0, 0), (-1, 0), colors.whitesmoke),
    ('ALIGN', (0, 0), (-1, -1), 'CENTER'),
    ('FONTNAME', (0, 0), (-1, 0), 'SimHei'),
    ('FONTSIZE', (0, 0), (-1, 0), 9),
    ('GRID', (0, 0), (-1, -1), 1, colors.black),
    ('BACKGROUND', (0, 1), (-1, -2), colors.beige),
    ('BACKGROUND', (0, -1), (-1, -1), colors.lightblue),
    ('FONTSIZE', (0, 1), (-1, -1), 8),
    # 表头行高
    ('ROWBACKGROUNDS', (0, 0), (-1, 0), [colors.grey]),
    # 设置行高
    ('LEFTPADDING', (0, 0), (-1, -1), 6),
    ('RIGHTPADDING', (0, 0), (-1, -1), 6)
]))
```

---

## 七、补充说明：持仓明细表

### 7.1 持仓明细表（如需要单独列出）

#### 位置和布局
- **位置**：可在第三页或独立页面
- **布局**：详细表格，列出所有持仓股票

#### 需要的数据

##### 7.1.1 持仓股票数据
- **股票代码**：6位股票代码
- **股票名称**：股票中文名称
  - 数据来源：交割单或Tushare
- **持仓数量**：当前持有股数
  - 数据来源：从交割单计算得出
- **持仓成本**：买入总成本（含手续费）
  - 计算公式：持仓成本 = Σ(买入金额 + 买入手续费)
- **持仓市值**：当前价格 × 持仓数量
  - 数据来源：当前价格从Tushare获取
- **盈亏金额**：持仓市值 - 持仓成本
- **盈亏比例**：盈亏金额 / 持仓成本 × 100%
- **持仓占比**：该股票市值 / 总资产 × 100%

#### 计算逻辑
```python
# 计算持仓明细
position_details = []
for stock_code, quantity in final_positions.items():
    # 获取股票名称
    stock_name = get_stock_name(stock_code)  # 从Tushare或交割单获取
    
    # 计算持仓成本
    cost = calculate_position_cost(stock_code)  # 从交割单计算
    
    # 获取当前价格
    current_price = get_stock_price(stock_code, report_date)  # 从Tushare获取
    
    # 计算持仓市值
    market_value = quantity * current_price
    
    # 计算盈亏
    profit_loss = market_value - cost
    profit_loss_pct = (profit_loss / cost * 100) if cost > 0 else 0
    
    # 计算持仓占比
    position_pct = (market_value / total_assets * 100) if total_assets > 0 else 0
    
    position_details.append({
        'code': stock_code,
        'name': stock_name,
        'quantity': quantity,
        'cost': cost,
        'market_value': market_value,
        'profit_loss': profit_loss,
        'profit_loss_pct': profit_loss_pct,
        'position_pct': position_pct
    })

# 按持仓市值排序
position_details.sort(key=lambda x: x['market_value'], reverse=True)
```

#### 实现方式
```python
# 创建持仓明细表
table_data = [
    ['股票代码', '股票名称', '持仓数量', '持仓成本(万元)', 
     '持仓市值(万元)', '盈亏金额(万元)', '盈亏比例(%)', '持仓占比(%)']
]

for pos in position_details:
    table_data.append([
        pos['code'],
        pos['name'],
        f"{pos['quantity']:.0f}",
        f"{pos['cost']:.2f}",
        f"{pos['market_value']:.2f}",
        f"{pos['profit_loss']:.2f}",
        f"{pos['profit_loss_pct']:.2f}",
        f"{pos['position_pct']:.2f}"
    ])

# 添加合计行
total_cost = sum([p['cost'] for p in position_details])
total_market_value = sum([p['market_value'] for p in position_details])
total_profit_loss = sum([p['profit_loss'] for p in position_details])

table_data.append([
    '合计', '', '', f"{total_cost:.2f}",
    f"{total_market_value:.2f}",
    f"{total_profit_loss:.2f}",
    f"{total_profit_loss/total_cost*100:.2f}" if total_cost > 0 else '0.00',
    '100.00'
])

table = Table(table_data, colWidths=[2*cm, 3*cm, 2*cm, 2.5*cm, 
                                      2.5*cm, 2.5*cm, 2*cm, 2*cm])
table.setStyle(TableStyle([
    ('BACKGROUND', (0, 0), (-1, 0), colors.grey),
    ('TEXTCOLOR', (0, 0), (-1, 0), colors.whitesmoke),
    ('ALIGN', (0, 0), (-1, -1), 'CENTER'),
    ('FONTNAME', (0, 0), (-1, 0), 'SimHei'),
    ('FONTSIZE', (0, 0), (-1, 0), 10),
    ('GRID', (0, 0), (-1, -1), 1, colors.black),
    ('BACKGROUND', (0, 1), (-1, -2), colors.beige),
    ('BACKGROUND', (0, -1), (-1, -1), colors.lightblue),
    ('FONTSIZE', (0, 1), (-1, -1), 9)
]))
```

---

### 7.2 行业分布分析（详细表格）

#### 位置和布局
- **位置**：大类资产绩效归因下方（如果需要），或作为第三页的补充
- **布局**：饼图 + 表格，显示行业分布

#### 需要的数据

##### 7.2.1 行业分类数据
- **数据来源**：
  - 从Tushare获取每只股票的行业分类
  - API接口：`stock_company()` 或 `stock_basic()`
- **计算逻辑**：
  ```python
  # 获取行业分类
  industry_mapping = {}
  for stock_code in final_positions.keys():
      industry = get_industry_from_tushare(stock_code)
      industry_mapping[stock_code] = industry
  
  # 按行业聚合
  industry_distribution = {}
  for pos in position_details:
      industry = industry_mapping.get(pos['code'], '未知行业')
      if industry not in industry_distribution:
          industry_distribution[industry] = {
              'market_value': 0,
              'stocks': []
          }
      industry_distribution[industry]['market_value'] += pos['market_value']
      industry_distribution[industry]['stocks'].append(pos)
  
  # 计算行业占比
  for industry in industry_distribution:
      industry_distribution[industry]['pct'] = (
          industry_distribution[industry]['market_value'] / 
          total_assets * 100
      )
  
  # 按市值排序
  sorted_industries = sorted(industry_distribution.items(), 
                              key=lambda x: x[1]['market_value'], 
                              reverse=True)
  ```

#### 实现方式

##### 饼图
```python
# 创建行业分布饼图
fig, ax = plt.subplots(figsize=(10, 10))

industries = [item[0] for item in sorted_industries]
market_values = [item[1]['market_value'] for item in sorted_industries]
pcts = [item[1]['pct'] for item in sorted_industries]

# 只显示前10个行业，其他归为"其他"
if len(industries) > 10:
    top_10_industries = industries[:10]
    top_10_values = market_values[:10]
    top_10_pcts = pcts[:10]
    
    other_value = sum(market_values[10:])
    other_pct = sum(pcts[10:])
    
    industries_display = top_10_industries + ['其他']
    values_display = top_10_values + [other_value]
    pcts_display = top_10_pcts + [other_pct]
else:
    industries_display = industries
    values_display = market_values
    pcts_display = pcts

# 创建饼图
wedges, texts, autotexts = ax.pie(values_display, 
                                   labels=industries_display,
                                   autopct='%1.1f%%',
                                   startangle=90)

ax.set_title('行业分布', fontsize=16, fontweight='bold')
plt.tight_layout()
plt.savefig('行业分布饼图.png', dpi=300, bbox_inches='tight')
```

##### 行业分布表格
```python
# 创建行业分布表格
industry_table_data = [
    ['行业', '持仓市值(万元)', '持仓占比(%)', '股票数量', '主要股票']
]

for industry, data in sorted_industries[:15]:  # 显示前15个行业
    stock_names = ', '.join([s['name'] for s in data['stocks'][:3]])  # 显示前3只股票
    if len(data['stocks']) > 3:
        stock_names += '...'
    
    industry_table_data.append([
        industry,
        f"{data['market_value']:.2f}",
        f"{data['pct']:.2f}",
        f"{len(data['stocks'])}",
        stock_names
    ])

# 添加合计行
total_mv = sum([d['market_value'] for _, d in sorted_industries])
industry_table_data.append([
    '合计',
    f"{total_mv:.2f}",
    '100.00',
    f"{len(position_details)}",
    ''
])

industry_table = Table(industry_table_data, 
                       colWidths=[4*cm, 3*cm, 3*cm, 2*cm, 6*cm])
industry_table.setStyle(TableStyle([
    ('BACKGROUND', (0, 0), (-1, 0), colors.grey),
    ('TEXTCOLOR', (0, 0), (-1, 0), colors.whitesmoke),
    ('ALIGN', (0, 0), (-1, -1), 'CENTER'),
    ('FONTNAME', (0, 0), (-1, 0), 'SimHei'),
    ('FONTSIZE', (0, 0), (-1, 0), 10),
    ('GRID', (0, 0), (-1, -1), 1, colors.black),
    ('BACKGROUND', (0, 1), (-1, -2), colors.beige),
    ('BACKGROUND', (0, -1), (-1, -1), colors.lightblue)
]))
```

---

## 八、数据依赖关系总结

### 8.1 核心数据流

```
交割单.xlsx
    ↓
[数据读取] → 交易记录（日期、股票代码、方向、数量、价格、手续费等）
    ↓
[持仓计算] → 持仓明细（股票代码、持仓数量、持仓成本）
    ↓
[Tushare API] → 股票价格、行业分类、基准指数数据
    ↓
[收益计算] → 收益率、回撤、波动率等指标
    ↓
[图表生成] → 各种可视化图表（matplotlib）
    ↓
[PDF生成] → 最终报告（reportlab）
```

### 8.2 必需的外部数据源

1. **交割单数据**（Excel文件）
   - 交易日期
   - 股票代码
   - 交易方向
   - 成交数量
   - 成交价格
   - 手续费
   - 印花税

2. **Tushare API数据**
   - 股票实时/历史价格（用于计算持仓市值）
   - 股票行业分类（用于行业分布分析）
   - 基准指数数据（用于对比分析）
   - 股票基本信息（股票名称等）

### 8.3 计算出的衍生数据

1. **每日数据**（需要按日计算）
   - 每日资产规模
   - 每日单位净值
   - 每日股票仓位
   - 每日资产分布
   - 每日回撤

2. **月度数据**（需要按月聚合）
   - 月度收益率
   - 月度累计收益率

3. **期末数据**（报告期末）
   - 持仓明细
   - 资产和负债明细
   - 行业分布

---

## 九、实现难点与注意事项

### 9.1 数据获取难点

1. **每日净值计算**
   - 需要获取每日的股票价格
   - 需要处理非交易日（使用前一交易日价格）
   - 需要处理停牌股票（使用停牌前最后价格）

2. **行业分类获取**
   - Tushare的行业分类可能不完整
   - 需要处理行业分类缺失的情况
   - 可能需要手动维护行业映射表

3. **基准指数数据**
   - 需要确保基准指数的日期与产品数据对齐
   - 需要处理指数数据的缺失情况

### 9.2 计算难点

1. **持仓成本计算**
   - 需要处理多次买入的情况（加权平均法）
   - 需要处理多次卖出的情况（成本分配）
   - 需要准确记录手续费

2. **回撤计算**
   - 需要维护峰值历史
   - 需要准确计算每个时间点的回撤
   - 需要记录最大回撤的起始和结束日期

3. **波动率计算**
   - 需要计算日收益率序列
   - 需要处理数据不足的情况
   - 需要处理非交易日的收益率缺失

4. **Brinson归因计算**
   - 需要获取基准指数的行业分布数据
   - 需要精确计算各行业的配置收益和选择收益
   - 需要处理行业分类标准不一致的问题

### 9.3 PDF生成难点

1. **中文字体支持**
   - 需要配置中文字体（SimHei、SimSun等）
   - 需要处理字体文件路径问题

2. **图表插入**
   - 需要将matplotlib图表保存为图片
   - 需要调整图片大小以适应PDF页面
   - 需要处理图片清晰度问题

3. **表格分页**
   - 持仓明细表可能很长，需要自动分页
   - 需要处理表格跨页的样式问题

4. **布局精确控制**
   - 需要精确控制每个元素的位置
   - 需要确保与模板格式一致

---

## 十、模块实现优先级

### 10.1 第一阶段：核心数据计算
1. ✅ 持仓计算模块
2. ✅ 收益计算模块
3. ✅ 基础指标计算（收益率、回撤等）

### 10.2 第二阶段：数据补全
1. ✅ Tushare API集成
2. ✅ 价格数据获取
3. ✅ 行业分类获取
4. ✅ 基准指数数据获取
5. ⚠️ PE、PB数据获取（如需要）
6. ⚠️ 债券数据获取（如有债券持仓）

### 10.3 第三阶段：图表生成
1. ✅ 产品规模走势图
2. ✅ 单位净值走势图
3. ✅ 收益率分析图
4. ✅ 动态回撤图
5. ✅ 资产分布时间图
6. ✅ 股票仓位时间图
7. ✅ 行业分布饼图
8. ✅ 持股行业占比时序图
9. ✅ 持股行业偏离度时序图
10. ✅ Brinson归因图
11. ⚠️ 债券评级分布图（如有债券持仓）
12. ⚠️ 债券久期分布图（如有债券持仓）

### 10.4 第四阶段：PDF生成
1. ✅ 封面页生成
2. ✅ 业绩统计表格
3. ✅ 图表插入
4. ✅ 持仓明细表格
5. ✅ 行业分布表格
6. ✅ 期末分布表格
7. ✅ 样式优化和格式调整

---

## 十一、各模块详细数据需求清单

### 11.1 第一页数据需求

#### 11.1.1 产品基本信息
- **产品名称**：配置项或固定值
- **净值日期**：报告期末日期（YYYY-MM-DD格式）

#### 11.1.2 业绩统计指标
- **期间产品收益率**：
  - 期初资产（初始资金1000万或上一年度末资产）
  - 期末资产（总资产）
  - 报告期间天数
- **期间收益**：
  - 期末资产 - 期初资产
- **最大回撤**：
  - 每日净值序列（需要按日计算）
- **波动率**：
  - 每日收益率序列（需要按日计算）
- **夏普比率**：
  - 年化收益率（已计算）
  - 年化波动率（已计算）
  - 无风险收益率（配置项，默认3%）
- **卡玛比率**：
  - 年化收益率（已计算）
  - 最大回撤（已计算）
- **同期对比**：
  - 基准指数（如沪深300）的期间收益率
  - 从Tushare获取指数数据

#### 11.1.3 产品规模走势图
- **资产规模数据**：
  - 每日资产规模（持仓市值 + 现金余额）
  - 需要按日计算所有持仓股票的市值
  - 需要按日计算现金余额
- **产品份额数据**：
  - 每日份额（资产规模 / 单位净值）
  - 如果产品没有份额概念，可以省略
- **申购/赎回数据**：
  - 每日申购金额
  - 每日赎回金额
  - 如果交割单中没有，设为0

#### 11.1.4 单位净值走势图
- **单位净值数据**：
  - 每日单位净值（资产规模 / 初始资金）
  - 需要按日计算
- **基准指数数据**：
  - 基准指数（如沪深300）的每日收盘价
  - 从Tushare获取
  - 计算基准指数的累计收益率

#### 11.1.5 收益率分析图
- **月度收益率**：
  - 每月初净值
  - 每月末净值
  - 需要按月份计算
- **累计收益率**：
  - 每月末的累计收益率
  - 基于初始净值计算

---

### 11.2 第二页数据需求

#### 11.2.1 动态回撤图
- **产品回撤数据**：
  - 每日净值序列
  - 需要维护峰值历史
- **基准回撤数据**：
  - 基准指数的每日价格
  - 从Tushare获取
  - 计算基准回撤

#### 11.2.2 资产分布时间图
- **资产分类数据**（按日计算）：
  - 股票市值：所有持仓股票的市值总和
  - 债券市值：通常为0
  - 现金：账户现金余额
  - 其他资产：通常为0

#### 11.2.3 期末分布表
- **资产明细**（报告期末）：
  - 股票市值：所有持仓股票的市值
  - 债券市值：通常为0
  - 逆回购：通常为0
  - 期货：通常为0
  - 期权：通常为0
  - 银行理财：通常为0
  - 其他证券：通常为0
  - 现金：现金余额
  - 其他资产：通常为0
- **负债明细**（报告期末）：
  - 逆回购：通常为0
  - 短期借款：通常为0
  - 融资融券：通常为0
  - 其他负债：如有，从交割单或账户余额计算

#### 11.2.4 股票仓位时间图
- **股票仓位数据**（按日计算）：
  - 每日股票市值
  - 每日总资产
  - 股票仓位 = 股票市值 / 总资产 × 100%

---

### 11.3 第三页及后续数据需求

#### 11.3.1 持仓明细表
- **持仓股票数据**（报告期末）：
  - 股票代码：从持仓计算得出
  - 股票名称：从Tushare或交割单获取
  - 持仓数量：从交割单计算得出
  - 持仓成本：从交割单计算得出（含手续费）
  - 持仓市值：当前价格 × 持仓数量（价格从Tushare获取）
  - 盈亏金额：持仓市值 - 持仓成本
  - 盈亏比例：盈亏金额 / 持仓成本 × 100%
  - 持仓占比：该股票市值 / 总资产 × 100%

#### 11.3.2 行业分布分析
- **行业分类数据**：
  - 每只股票的行业分类（从Tushare获取）
  - API接口：`stock_company()` 或 `stock_basic()`
- **行业聚合数据**：
  - 每个行业的持仓市值
  - 每个行业的持仓占比
  - 每个行业下的股票列表

---

## 八、关键计算函数清单

### 8.1 持仓相关计算

#### 8.1.1 计算持仓数量
```python
def calculate_position_quantity(transactions, stock_code, end_date):
    """
    计算指定股票在指定日期的持仓数量
    """
    quantity = 0
    for trans in transactions:
        if trans['date'] <= end_date and trans['code'] == stock_code:
            if trans['direction'] == '买入':
                quantity += trans['quantity']
            elif trans['direction'] == '卖出':
                quantity -= trans['quantity']
    return quantity
```

#### 8.1.2 计算持仓成本
```python
def calculate_position_cost(transactions, stock_code, end_date):
    """
    计算指定股票在指定日期的持仓成本（加权平均法）
    """
    total_cost = 0
    total_quantity = 0
    for trans in transactions:
        if trans['date'] <= end_date and trans['code'] == stock_code:
            if trans['direction'] == '买入':
                cost = trans['amount'] + trans['fee']
                total_cost += cost
                total_quantity += trans['quantity']
    return total_cost if total_quantity > 0 else 0
```

#### 8.1.3 计算持仓市值
```python
def calculate_position_value(stock_code, quantity, date):
    """
    计算指定股票在指定日期的持仓市值
    """
    price = get_stock_price_from_tushare(stock_code, date)
    return quantity * price
```

### 8.2 收益相关计算

#### 8.2.1 计算已实现收益
```python
def calculate_realized_profit(transactions, end_date):
    """
    计算指定日期前的已实现收益
    """
    realized_profit = 0
    for trans in transactions:
        if trans['date'] <= end_date and trans['direction'] == '卖出':
            # 计算卖出成本（使用加权平均成本）
            cost = calculate_position_cost(transactions, trans['code'], trans['date'])
            quantity = calculate_position_quantity(transactions, trans['code'], trans['date'])
            avg_cost = cost / quantity if quantity > 0 else 0
            
            # 计算已实现盈亏
            sell_amount = trans['amount']
            sell_cost = avg_cost * trans['quantity']
            profit = sell_amount - sell_cost - trans['fee'] - trans['stamp_tax']
            realized_profit += profit
    return realized_profit
```

#### 8.2.2 计算未实现收益
```python
def calculate_unrealized_profit(positions, date):
    """
    计算指定日期的未实现收益
    """
    unrealized_profit = 0
    for stock_code, quantity in positions.items():
        cost = calculate_position_cost(transactions, stock_code, date)
        market_value = calculate_position_value(stock_code, quantity, date)
        unrealized_profit += (market_value - cost)
    return unrealized_profit
```

### 8.3 指标相关计算

#### 8.3.1 计算最大回撤
```python
def calculate_max_drawdown(daily_navs):
    """
    计算最大回撤
    daily_navs: [(date, nav), ...]
    """
    max_drawdown = 0
    peak = daily_navs[0][1]
    for date, nav in daily_navs:
        if nav > peak:
            peak = nav
        drawdown = (peak - nav) / peak * 100
        if drawdown > max_drawdown:
            max_drawdown = drawdown
    return max_drawdown
```

#### 8.3.2 计算波动率
```python
def calculate_volatility(daily_navs):
    """
    计算年化波动率
    """
    import numpy as np
    returns = []
    for i in range(1, len(daily_navs)):
        ret = (daily_navs[i][1] - daily_navs[i-1][1]) / daily_navs[i-1][1]
        returns.append(ret)
    return np.std(returns) * np.sqrt(252) * 100
```

#### 8.3.3 计算夏普比率
```python
def calculate_sharpe_ratio(annualized_return, volatility, risk_free_rate=0.03):
    """
    计算夏普比率
    """
    return (annualized_return/100 - risk_free_rate) / (volatility/100)
```

#### 8.3.4 计算卡玛比率
```python
def calculate_calmar_ratio(annualized_return, max_drawdown):
    """
    计算卡玛比率
    """
    if max_drawdown == 0:
        return 0
    return (annualized_return/100) / (abs(max_drawdown)/100)
```

#### 8.3.5 计算周胜率
```python
def calculate_weekly_win_rate(daily_navs):
    """
    计算周胜率
    """
    # 按周聚合净值
    weekly_navs = []
    for week_start in week_range:
        week_end = week_start + timedelta(days=6)
        week_navs = [nav for date, nav in daily_navs 
                    if week_start <= date <= week_end]
        if week_navs:
            weekly_navs.append((week_start, week_navs[0], week_navs[-1]))
    
    # 计算盈利周数
    winning_weeks = 0
    for week_start, start_nav, end_nav in weekly_navs:
        if end_nav > start_nav:
            winning_weeks += 1
    
    return winning_weeks / len(weekly_navs) * 100 if weekly_navs else 0
```

#### 8.3.6 计算月胜率
```python
def calculate_monthly_win_rate(daily_navs):
    """
    计算月胜率
    """
    # 按月聚合净值
    monthly_navs = []
    for month in range(1, 13):
        month_start = f"{target_year}-{month:02d}-01"
        month_end = f"{target_year}-{month:02d}-{calendar.monthrange(target_year, month)[1]}"
        month_navs = [nav for date, nav in daily_navs 
                     if month_start <= str(date) <= month_end]
        if month_navs:
            monthly_navs.append((month, month_navs[0], month_navs[-1]))
    
    # 计算盈利月数
    winning_months = 0
    for month, start_nav, end_nav in monthly_navs:
        if end_nav > start_nav:
            winning_months += 1
    
    return winning_months / len(monthly_navs) * 100 if monthly_navs else 0
```

---

## 九、Tushare API调用清单

### 9.1 必需API调用

#### 9.1.1 获取股票基本信息
```python
# API: stock_basic
# 用途：获取股票名称、上市日期等基本信息
pro.stock_basic(exchange='', list_status='L', 
                fields='ts_code,symbol,name,area,industry,list_date')
```

#### 9.1.2 获取股票行业分类
```python
# API: stock_company
# 用途：获取股票的行业分类
pro.stock_company(exchange='', fields='ts_code,industry')
```

#### 9.1.3 获取股票日线行情
```python
# API: daily 或 pro_bar
# 用途：获取股票每日价格（用于计算持仓市值）
pro.daily(ts_code='000001.SZ', start_date='20240101', end_date='20241231')
```

#### 9.1.4 获取基准指数数据
```python
# API: index_daily
# 用途：获取基准指数（如沪深300）的每日行情
pro.index_daily(ts_code='000300.SH', start_date='20240101', end_date='20241231')
```

### 9.2 批量获取优化

#### 9.2.1 批量获取股票信息
```python
def batch_get_stock_info(stock_codes):
    """
    批量获取股票基本信息
    """
    # 获取所有股票基本信息（一次性）
    all_stocks = pro.stock_basic(exchange='', list_status='L')
    # 建立映射
    stock_info_map = {}
    for code in stock_codes:
        # 转换代码格式（如：000001 -> 000001.SZ）
        ts_code = convert_to_ts_code(code)
        stock_info = all_stocks[all_stocks['ts_code'] == ts_code]
        if not stock_info.empty:
            stock_info_map[code] = stock_info.iloc[0].to_dict()
    return stock_info_map
```

#### 9.2.2 批量获取股票价格
```python
def batch_get_stock_prices(stock_codes, date):
    """
    批量获取指定日期的股票价格
    """
    prices = {}
    for code in stock_codes:
        ts_code = convert_to_ts_code(code)
        try:
            data = pro.daily(ts_code=ts_code, trade_date=date.replace('-', ''))
            if not data.empty:
                prices[code] = data.iloc[0]['close']
        except:
            prices[code] = None
    return prices
```

---

## 十、数据验证与错误处理

### 10.1 数据验证检查点

#### 10.1.1 交割单数据验证
- ✅ 检查必需字段是否存在
- ✅ 检查日期格式是否正确
- ✅ 检查股票代码格式（6位数字）
- ✅ 检查交易方向是否有效（买入/卖出）
- ✅ 检查成交数量是否为正数
- ✅ 检查成交价格是否为正数
- ✅ 检查持仓数量是否出现负数（数据异常）

#### 10.1.2 计算结果验证
- ✅ 检查总资产是否等于持仓市值 + 现金
- ✅ 检查持仓占比之和是否等于100%
- ✅ 检查行业分布占比之和是否等于100%
- ✅ 检查已实现收益 + 未实现收益是否等于总收益

### 10.2 错误处理策略

#### 10.2.1 Tushare API调用失败
- **策略1**：使用缓存的历史数据
- **策略2**：标记为"数据不可用"，使用默认值
- **策略3**：记录错误日志，继续处理其他数据

#### 10.2.2 股票价格缺失
- **策略1**：使用最近可用价格
- **策略2**：使用停牌前最后价格
- **策略3**：标记为"价格不可用"，在报告中注明

#### 10.2.3 行业分类缺失
- **策略1**：标记为"未知行业"
- **策略2**：尝试使用其他数据源
- **策略3**：手动维护行业映射表

---

## 十一、性能优化建议

### 11.1 数据获取优化

#### 11.1.1 Tushare API调用优化
- 使用批量获取接口，减少API调用次数
- 实现缓存机制，避免重复调用
- 使用多线程或异步调用（如果API支持）

#### 11.1.2 价格数据获取优化
- 一次性获取所有需要的日期和股票的价格数据
- 建立本地价格数据库，避免重复API调用
- 对于非交易日，使用前一交易日价格

### 11.2 计算优化

#### 11.2.1 持仓计算优化
- 使用pandas向量化操作
- 避免循环处理大量数据
- 使用索引加速查询

#### 11.2.2 每日数据计算优化
- 按时间顺序一次性计算所有每日数据
- 避免重复计算相同日期的数据
- 使用缓存机制

---

## 十二、测试检查清单

### 12.1 功能测试

- [ ] 交割单数据读取是否正确
- [ ] 持仓计算是否准确
- [ ] 收益计算是否准确
- [ ] Tushare数据获取是否成功
- [ ] 行业分类是否正确
- [ ] 图表生成是否正常
- [ ] PDF生成是否成功

### 12.2 数据验证测试

- [ ] 总资产 = 持仓市值 + 现金（期末）
- [ ] 持仓占比之和 = 100%
- [ ] 行业分布占比之和 = 100%
- [ ] 已实现收益 + 未实现收益 = 总收益
- [ ] 所有数值计算与手动计算结果一致

### 12.3 边界情况测试

- [ ] 处理空持仓情况
- [ ] 处理单只股票情况
- [ ] 处理无交易记录的情况
- [ ] 处理Tushare API失败的情况
- [ ] 处理股票退市的情况
- [ ] 处理数据缺失的情况

---

## 十三、总结

### 13.1 核心实现要点

1. **数据完整性**：确保从交割单和Tushare获取所有必需数据
2. **计算准确性**：持仓成本、收益计算必须精确
3. **时间序列处理**：需要按日计算净值、回撤等指标
4. **图表生成**：使用matplotlib生成高质量图表
5. **PDF格式匹配**：生成的PDF要与模板格式一致

### 13.2 关键技术难点

1. **每日净值计算**：需要获取每日股票价格，处理非交易日
2. **持仓成本计算**：需要处理多次买卖的复杂情况
3. **回撤计算**：需要维护峰值历史
4. **行业分类获取**：需要处理数据缺失的情况
5. **PDF格式控制**：需要精确控制布局和样式

### 13.3 实现建议

1. **分阶段实现**：按照优先级逐步实现各个模块
2. **充分测试**：每个模块都要进行充分测试
3. **错误处理**：完善错误处理机制，确保程序健壮性
4. **性能优化**：注意API调用频率和计算效率
5. **文档维护**：保持代码和文档同步更新

---

---

## 十四、模板PDF完整结构总结

### 14.1 第一页：总体表现
1. ✅ 产品基本信息（产品名称、净值日期、成立日期、累计净值、当前规模、单位净值、收益风险特征、投资策略、同策略收益排名）
2. ✅ 业绩统计（期间产品收益率、期间收益、最大回撤、波动率、夏普比率、β值、主动收益、同期对比）
3. ✅ 产品规模总览（统计表格 + 走势图）
4. ✅ 单位净值表现（复权累计收益、沪深300、累计超额收益）
5. ✅ 日收益表现（日收益率、累计收益率、单日最大收益、单日最大亏损）
6. ✅ 收益分析表格（多时间段收益率对比）
7. ✅ 指标分析表格（多指标、多时间段，包含跟踪误差、下行波动率、索提诺比率、信息比率、卡玛比率、周胜率、月胜率）

### 14.2 第二页：风险分析与资产分布
1. ✅ 动态回撤图（产品回撤、基准回撤、最大回撤区间、最大回撤修复期）
2. ✅ 大类持仓时序图（股票、基金、逆回购、现金、其他资产）
3. ✅ 期末分布表（资产和负债明细）
4. ✅ 股票仓位时序图（股票仓位、TOP10仓位、沪深300）
5. ✅ 流动性资产时序图（流动性资产比例、沪深300）

### 14.3 第三页：行业分析与绩效归因
1. ✅ 持股行业分析
   - 期末市值占比图（前十大行业、剩余行业）
   - 期间平均市值占产品净资产比
   - 期末持股行业风格表格（组合PE、组合PB、行业平均PE、行业平均PB）
   - 持股行业占比时序图
   - 持股行业偏离度时序图
2. ✅ 大类资产绩效归因（股票、公募基金、逆回购等）
3. ✅ 行业分布分析（详细表格和饼图）

### 14.4 第四页：Brinson归因与行业归因
1. ✅ Brinson归因
   - 选择收益时序图
   - 配置收益时序图
   - 归因分析结果（个股选择收益、行业配置收益）
2. ✅ 股票行业归因
   - 按照收益额排名前十的行业
   - 按照亏损额排名前十的行业
   - 每个行业的权重、贡献度、收益额、选择收益、配置收益

### 14.5 第五页：股票绩效归因与期货归因
1. ✅ 股票绩效归因
   - 盈利前十的股票
   - 亏损前十的股票
   - 每只股票的权重、贡献度、收益额
2. ✅ 个股持仓节点（TOP1、TOP2、TOP3、TOP5、TOP10、TOP50、TOP100）
3. ✅ 期货分类归因（股指期货、商品期货、国债期货）
4. ✅ 期货板块归因（各板块的多空持仓、收益额、板块指数涨跌）

### 14.6 第六页：债券分析与交易统计
1. ✅ 评级分布&久期分布（债券评级分布、组合加权修正久期、久期分布）
2. ✅ 债券行业分布
3. ✅ 债券策略_债券收益风险分析（如有债券持仓）
4. ✅ 换手率（年化）（各资产类别、多时间段）
5. ✅ 期间交易统计（买入金额、卖出金额）
6. ✅ 前十大买卖期货（多头、空头、交易金额、总盈亏）

---

## 十五、缺失数据完整清单

### 15.1 需要从交割单获取的数据
- ✅ 交易日期
- ✅ 股票代码
- ✅ 股票名称（可能缺失，可通过Tushare补全）
- ✅ 交易方向（买入/卖出）
- ✅ 成交数量
- ✅ 成交价格
- ✅ 成交金额
- ✅ 手续费
- ✅ 印花税
- ⚠️ 期货交易数据（如有期货持仓）
- ⚠️ 债券交易数据（如有债券持仓）

### 15.2 需要从Tushare获取的数据

#### 必需数据
1. ✅ **行业分类信息**
   - API接口：`stock_company()` 或 `stock_basic()`
   - 字段：行业分类代码、行业名称
   - 用途：生成行业分布分析、行业归因

2. ✅ **实时/历史价格数据**
   - API接口：`daily()` 或 `pro_bar()`
   - 字段：收盘价、交易日期
   - 用途：计算持仓市值、未实现收益、每日净值

3. ✅ **基准指数数据**
   - API接口：`index_daily()`
   - 字段：收盘价、交易日期
   - 用途：对比分析、Brinson归因

4. ✅ **股票基本信息**
   - API接口：`stock_basic()`
   - 字段：股票名称、上市日期、退市日期
   - 用途：数据验证、持仓明细

#### 可选但重要的数据
5. ⚠️ **股票PE、PB数据**
   - API接口：`daily_basic()` 或 `fina_indicator()`
   - 字段：市盈率(PE)、市净率(PB)
   - 用途：计算组合PE、PB，行业风格分析

6. ⚠️ **行业平均PE、PB数据**
   - API接口：可能需要Wind或专业数据源
   - 用途：行业风格对比

7. ⚠️ **板块指数数据**
   - API接口：`index_daily()`（针对各期货板块）
   - 用途：期货板块归因

8. ⚠️ **债券评级和久期数据**
   - 如有债券持仓，需要债券数据源
   - 用途：债券评级分布、久期分布

### 15.3 需要计算生成的衍生数据

#### 每日数据
- ✅ 每日资产规模
- ✅ 每日单位净值
- ✅ 每日股票仓位
- ✅ 每日资产分布
- ✅ 每日回撤
- ✅ 每日行业占比
- ✅ 每日行业偏离度
- ✅ 每日流动性资产比例

#### 每周数据
- ✅ 周收益率（用于计算周胜率）

#### 每月数据
- ✅ 月度收益率
- ✅ 月度累计收益率
- ✅ 月收益率（用于计算月胜率）

#### 期末数据
- ✅ 持仓明细
- ✅ 资产和负债明细
- ✅ 行业分布
- ✅ 行业风格（PE、PB）
- ✅ 股票绩效排名
- ✅ 行业归因排名

---

## 十六、实现注意事项补充

### 16.1 数据获取注意事项

#### 16.1.1 行业分类标准
- **行业因子筛选自申万一级行业**：模板中明确标注使用申万一级行业分类
- 需要确保Tushare返回的行业分类与申万一级行业标准一致
- 如果Tushare使用的分类标准不同，需要建立映射关系

#### 16.1.2 PE、PB数据获取
- 组合PE和PB需要从Tushare获取个股的PE、PB数据
- 行业平均PE、PB可能需要从Wind或其他专业数据源获取
- 如果无法获取，可以考虑使用行业指数的PE、PB作为替代

#### 16.1.3 期货数据处理
- 期货合约代码格式可能与股票不同
- 需要识别期货交易（通过代码格式或交割单字段）
- 期货的多空持仓计算方式与股票不同

### 16.2 计算注意事项

#### 16.2.1 Brinson归因计算
- Brinson归因需要基准指数的行业分布数据
- 需要确保产品与基准的行业分类标准一致
- 选择收益和配置收益的计算需要精确

#### 16.2.2 行业偏离度计算
- 需要获取基准指数（如沪深300）的行业分布
- 计算每日的产品行业分布和基准行业分布
- 计算两者偏离度的平均值

#### 16.2.3 期间平均市值计算
- 需要计算每个行业在报告期间的平均持仓市值
- 需要计算期间平均净资产
- 计算期间平均市值占产品净资产比

### 16.3 PDF生成注意事项

#### 16.3.1 图表数量较多
- 第一页包含多个图表，需要合理布局
- 第二页包含多个时序图，需要注意图表大小和位置
- 第三页包含行业分析图表，需要合理安排空间

#### 16.3.2 表格数据量大
- 指标分析表格包含多行多列，需要处理分页
- 行业归因表格可能较长，需要合理排版
- 持仓明细表如果股票数量多，需要分页处理

#### 16.3.3 字体和样式
- 确保所有中文字体正确显示
- 表格样式需要统一
- 图表标题和标签需要清晰

---

**文档版本**：v2.0  
**创建日期**：2024年  
**最后更新**：2024年  
**文档状态**：完整（已包含所有6页内容）